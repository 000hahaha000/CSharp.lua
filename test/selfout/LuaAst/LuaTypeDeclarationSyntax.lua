-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua.LuaAst", function (namespace) 
    namespace.class("LuaTypeDeclarationSyntax", function (namespace) 
        local AddStaticReadOnlyAssignmentName, AddTypeIdentifier, AddResultTable, AddResultTable, AddMethod, AddInitFiled, AddInitFiled, AddField, 
        AddPropertyOrEvent, AddProperty, AddEvent, SetStaticCtor, AddCtor, AddInitFunction, AddStaticAssignmentNames, AddStaticCtorFunction, 
        AddCtorsFunction, AddBaseTypes, Render, __init__, __ctor__;
        __init__ = function (this) 
            this.local_ = CSharpLua.LuaAst.LuaTypeLocalAreaSyntax();
            this.methodList_ = CSharpLua.LuaAst.LuaStatementListSyntax();
            this.resultTable_ = CSharpLua.LuaAst.LuaTableInitializerExpression();
            this.staticAssignmentNames_ = System.List(System.String)();
            this.ctors_ = System.List(CSharpLua.LuaAst.LuaConstructorAdapterExpressionSyntax)();
            this.typeIdentifiers_ = System.List(CSharpLua.LuaAst.LuaIdentifierNameSyntax)();
        end;
        __ctor__ = function (this) 
            __init__(this);
        end;
        AddStaticReadOnlyAssignmentName = function (this, name) 
            if not this.staticAssignmentNames_:Contains(name) then
                this.staticAssignmentNames_:Add(name);
            end
        end;
        AddTypeIdentifier = function (this, identifier) 
            this.typeIdentifiers_:Add(identifier);
        end;
        AddResultTable = function (this, name) 
            local item = CSharpLua.LuaAst.LuaKeyValueTableItemSyntax(CSharpLua.LuaAst.LuaTableLiteralKeySyntax(name), name);
            this.resultTable_.Items:Add(item);
        end;
        AddResultTable = function (this, name, value) 
            local item = CSharpLua.LuaAst.LuaKeyValueTableItemSyntax(CSharpLua.LuaAst.LuaTableLiteralKeySyntax(name), value);
            this.resultTable_.Items:Add(item);
        end;
        AddMethod = function (this, name, method, isPrivate) 
            this.local_.Variables:Add(name);
            local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(name, method);
            this.methodList_.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
            if not isPrivate then
                AddResultTable(this, name);
            end
        end;
        AddInitFiled = function (this, initFunction, assignment) 
            if initFunction == nil then
                initFunction = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
                initFunction:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
            end
            initFunction.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
        end;
        AddInitFiled = function (this, initFunction, name, value) 
            local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This, name);
            local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(memberAccess, value);
            initFunction = AddInitFiled(this, initFunction, assignment);
        end;
        AddField = function (this, name, value, isImmutable, isStatic, isPrivate, isReadOnly) 
            if isStatic then
                if isPrivate then
                    this.local_.Variables:Add(name);
                    if value ~= nil then
                        local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(name, value);
                        if isImmutable then
                            this.methodList_.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
                        else
                            this.staticInitFunction_ = AddInitFiled(this, this.staticInitFunction_, assignment);
                        end
                    end
                else
                    if isReadOnly then
                        this.local_.Variables:Add(name);
                        if value ~= nil then
                            local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(name, value);
                            if isImmutable then
                                this.methodList_.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
                                AddResultTable(this, name);
                            else
                                this.staticInitFunction_ = AddInitFiled(this, this.staticInitFunction_, assignment);
                                this.staticAssignmentNames_:Add(name.ValueText);
                            end
                        end
                    else
                        if value ~= nil then
                            if isImmutable then
                                AddResultTable(this, name, value);
                            else
                                this.staticInitFunction_ = AddInitFiled(this, this.staticInitFunction_, name, value);
                            end
                        end
                    end
                end
            else
                if value ~= nil then
                    if isImmutable then
                        AddResultTable(this, name, value);
                    else
                        this.initFunction_ = AddInitFiled(this, this.initFunction_, name, value);
                    end
                end
            end
        end;
        AddPropertyOrEvent = function (this, isProperty, name, value, isImmutable, isStatic, isPrivate) 
            local getToken, setToken;
            local initMethodIdentifier;
            if isProperty then
                getToken = "get" --[[Tokens.Get]];
                setToken = "set" --[[Tokens.Set]];
                initMethodIdentifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax.Property;
            else
                getToken = "add" --[[Tokens.Add]];
                setToken = "remove" --[[Tokens.Remove]];
                initMethodIdentifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax.Event;
            end

            local identifierName = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
            local get = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, (getToken or "") .. (name or ""));
            local set = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, (setToken or "") .. (name or ""));
            this.local_.Variables:Add(get);
            this.local_.Variables:Add(set);
            local assignment = CSharpLua.LuaAst.LuaMultipleAssignmentExpressionSyntax();
            assignment.Lefts:Add(get);
            assignment.Lefts:Add(set);
            local invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, initMethodIdentifier);
            invocation:AddArgument(CSharpLua.LuaAst.LuaStringLiteralExpressionSyntax:new(1, identifierName));
            assignment.Rights:Add(invocation);
            this:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));

            if value ~= nil then
                if isStatic then
                    if isImmutable then
                        AddResultTable(this, identifierName, value);
                    else
                        this.staticInitFunction_ = AddInitFiled(this, this.staticInitFunction_, identifierName, value);
                    end
                else
                    if isImmutable then
                        AddResultTable(this, identifierName, value);
                    else
                        this.initFunction_ = AddInitFiled(this, this.initFunction_, identifierName, value);
                    end
                end
            end

            if not isPrivate then
                AddResultTable(this, get);
                AddResultTable(this, set);
            end
        end;
        AddProperty = function (this, name, value, isImmutable, isStatic, isPrivate) 
            AddPropertyOrEvent(this, true, name, value, isImmutable, isStatic, isPrivate);
        end;
        AddEvent = function (this, name, value, isImmutable, isStatic, isPrivate) 
            AddPropertyOrEvent(this, false, name, value, isImmutable, isStatic, isPrivate);
        end;
        SetStaticCtor = function (this, function_) 
            assert(this.staticCtorFunction_ == nil);
            this.staticCtorFunction_ = function_;
        end;
        AddCtor = function (this, function_) 
            this.ctors_:Add(function_);
        end;
        AddInitFunction = function (this, name, initFunction, isAddItem) 
            if isAddItem == nil then isAddItem = true end
            local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(name, initFunction);
            this:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
            this.local_.Variables:Add(name);
            if isAddItem then
                AddResultTable(this, name);
            end
        end;
        AddStaticAssignmentNames = function (this, body) 
            if #this.staticAssignmentNames_ > 0 then
                local assignment = CSharpLua.LuaAst.LuaMultipleAssignmentExpressionSyntax();
                for _, name in System.each(this.staticAssignmentNames_) do
                    local identifierName = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
                    local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This, identifierName);
                    assignment.Lefts:Add(memberAccess);
                    assignment.Rights:Add(identifierName);
                end
                body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
            end
        end;
        AddStaticCtorFunction = function (this) 
            local hasStaticInit = this.staticInitFunction_ ~= nil;
            local hasStaticCtor = this.staticCtorFunction_ ~= nil;

            if hasStaticCtor then
                if hasStaticInit then
                    this.staticCtorFunction_.Body.Statements:InsertRange(0, this.staticInitFunction_.Body.Statements);
                end
                AddStaticAssignmentNames(this, this.staticCtorFunction_.Body);
                AddInitFunction(this, CSharpLua.LuaAst.LuaIdentifierNameSyntax.StaticCtor, this.staticCtorFunction_);
            else
                if hasStaticInit then
                    AddStaticAssignmentNames(this, this.staticInitFunction_.Body);
                    AddInitFunction(this, CSharpLua.LuaAst.LuaIdentifierNameSyntax.StaticCtor, this.staticInitFunction_);
                end
            end
        end;
        AddCtorsFunction = function (this) 
            local hasInit = this.initFunction_ ~= nil;
            local hasCtors = #this.ctors_ > 0;

            if hasCtors then
                if hasInit then
                    local initIdentifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax.Init;
                    AddInitFunction(this, initIdentifier, this.initFunction_, false);
                    for _, ctor in System.each(this.ctors_) do
                        if not ctor.IsInvokeThisCtor then
                            local invocationInit = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, initIdentifier, CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                            ctor.Body.Statements:Insert(0, CSharpLua.LuaAst.LuaExpressionStatementSyntax(invocationInit));
                        end
                    end
                end

                if #this.ctors_ == 1 then
                    AddInitFunction(this, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Ctor, CSharpLua.Utility.First(this.ctors_, CSharpLua.LuaAst.LuaConstructorAdapterExpressionSyntax));
                else
                    local ctrosTable = CSharpLua.LuaAst.LuaTableInitializerExpression();
                    local index = 1;
                    for _, ctor in System.each(this.ctors_) do
                        local name = CSharpLua.LuaAst.LuaSyntaxNode.SpecailWord("ctor" --[[Tokens.Ctor]] .. index);
                        local nameIdentifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
                        AddInitFunction(this, nameIdentifier, ctor, false);
                        ctrosTable.Items:Add(CSharpLua.LuaAst.LuaSingleTableItemSyntax(nameIdentifier));
                        index = index + 1;
                    end
                    AddResultTable(this, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Ctor, ctrosTable);
                end
            else
                if hasInit then
                    AddInitFunction(this, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Ctor, this.initFunction_);
                end
            end
        end;
        AddBaseTypes = function (this, baseTypes) 
            local table = CSharpLua.LuaAst.LuaTableInitializerExpression();
            table.Items:AddRange(Linq.Select(baseTypes, function (i) return CSharpLua.LuaAst.LuaSingleTableItemSyntax(i); end, CSharpLua.LuaAst.LuaSingleTableItemSyntax));
            AddResultTable(this, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Inherits, table);
        end;
        Render = function (this, renderer) 
            if this.IsPartialMark then
                return;
            end

            this:Add(this.local_);
            AddStaticCtorFunction(this);
            AddCtorsFunction(this);
            this:Add(this.methodList_);

            local returnStatement = CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, this.resultTable_);
            this:Add(returnStatement);

            if #this.typeIdentifiers_ > 0 then
                local wrapFunction = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
                for _, type in System.each(this.typeIdentifiers_) do
                    wrapFunction:AddParameter(type);
                end
                wrapFunction.Body.Statements:AddRange(this.statements_);
                this.statements_:Clear();
                this.statements_:Add(CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, wrapFunction));
            end
            CSharpLua.LuaAst.LuaWrapFunctionStatementSynatx.Render(this, renderer);
        end;
        return {
            __inherits__ = {
                CSharpLua.LuaAst.LuaWrapFunctionStatementSynatx
            }, 
            IsPartialMark = False, 
            AddStaticReadOnlyAssignmentName = AddStaticReadOnlyAssignmentName, 
            AddTypeIdentifier = AddTypeIdentifier, 
            AddMethod = AddMethod, 
            AddField = AddField, 
            AddProperty = AddProperty, 
            AddEvent = AddEvent, 
            SetStaticCtor = SetStaticCtor, 
            AddCtor = AddCtor, 
            AddBaseTypes = AddBaseTypes, 
            Render = Render, 
            __ctor__ = __ctor__
        };
    end);
    namespace.class("LuaClassDeclarationSyntax", function (namespace) 
        local __ctor__;
        __ctor__ = function (this, name) 
            this:UpdateIdentifiers(name, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Namespace, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Class, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Namespace);
        end;
        return {
            __inherits__ = {
                CSharpLua.LuaAst.LuaTypeDeclarationSyntax
            }, 
            __ctor__ = __ctor__
        };
    end);
    namespace.class("LuaStructDeclarationSyntax", function (namespace) 
        local __ctor__;
        __ctor__ = function (this, name) 
            this:UpdateIdentifiers(name, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Namespace, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Struct, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Namespace);
        end;
        return {
            __inherits__ = {
                CSharpLua.LuaAst.LuaTypeDeclarationSyntax
            }, 
            __ctor__ = __ctor__
        };
    end);
    namespace.class("LuaInterfaceDeclarationSyntax", function (namespace) 
        local __ctor__;
        __ctor__ = function (this, name) 
            this:UpdateIdentifiers(name, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Namespace, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Interface);
        end;
        return {
            __inherits__ = {
                CSharpLua.LuaAst.LuaTypeDeclarationSyntax
            }, 
            __ctor__ = __ctor__
        };
    end);
    namespace.class("LuaEnumDeclarationSyntax", function (namespace) 
        local Add, Render, __ctor__;
        __ctor__ = function (this, fullName, name) 
            this.FullName = fullName;
            this:UpdateIdentifiers(name, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Namespace, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Enum);
        end;
        Add = function (this, statement) 
            this.resultTable_.Items:Add(statement);
        end;
        Render = function (this, renderer) 
            if renderer:IsEnumExport(this.FullName) then
                CSharpLua.LuaAst.LuaTypeDeclarationSyntax.Render(this, renderer);
            end
        end;
        return {
            __inherits__ = {
                CSharpLua.LuaAst.LuaTypeDeclarationSyntax
            }, 
            Add = Add, 
            Render = Render, 
            __ctor__ = __ctor__
        };
    end);
end);
