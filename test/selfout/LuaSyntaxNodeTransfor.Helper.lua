-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua", function (namespace) 
    namespace.class("LuaSyntaxNodeTransfor", function (namespace) 
        namespace.class("LuaSyntaxSearcher", function (namespace) 
            namespace.class("FoundException", function (namespace) 
                return {
                    __inherits__ = {
                        System.Exception
                    }
                };
            end);
            local Found, Find;
            Found = function (this) 
                System.throw(CSharpLua.LuaSyntaxNodeTransfor.LuaSyntaxSearcher.FoundException());
            end;
            Find = function (this, root) 
                local default, extern = System.try(function () 
                    this:Visit(root);
                end, function (default) 
                    if System.is(default, CSharpLua.LuaSyntaxNodeTransfor.LuaSyntaxSearcher.FoundException) then
                        return true, true;
                    else
                        return 1, default;
                    end
                end);
                if default then
                    return extern;
                end
                return false;
            end;
            return {
                __inherits__ = {
                    Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker
                }, 
                Found = Found, 
                Find = Find
            };
        end);
        namespace.class("LocalVarSearcher", function (namespace) 
            local VisitParameter, VisitVariableDeclarator, __ctor__;
            __ctor__ = function (this, name) 
                this.name_ = name;
            end;
            VisitParameter = function (this, node) 
                if node:getIdentifier():getValueText() == this.name_ then
                    this:Found();
                end
            end;
            VisitVariableDeclarator = function (this, node) 
                if node:getIdentifier():getValueText() == this.name_ then
                    this:Found();
                end
            end;
            return {
                __inherits__ = {
                    CSharpLua.LuaSyntaxNodeTransfor.LuaSyntaxSearcher
                }, 
                VisitParameter = VisitParameter, 
                VisitVariableDeclarator = VisitVariableDeclarator, 
                __ctor__ = __ctor__
            };
        end);
        namespace.class("ContinueSearcher", function (namespace) 
            local VisitContinueStatement;
            VisitContinueStatement = function (this, node) 
                this:Found();
            end;
            return {
                __inherits__ = {
                    CSharpLua.LuaSyntaxNodeTransfor.LuaSyntaxSearcher
                }, 
                VisitContinueStatement = VisitContinueStatement
            };
        end);
        namespace.class("ReturnStatementSearcher", function (namespace) 
            local VisitReturnStatement;
            VisitReturnStatement = function (this, node) 
                this:Found();
            end;
            return {
                __inherits__ = {
                    CSharpLua.LuaSyntaxNodeTransfor.LuaSyntaxSearcher
                }, 
                VisitReturnStatement = VisitReturnStatement
            };
        end);
        local codeTemplateRegex_, IsLocalVarExists, GetNewIdentifierName, FindParent, FindParent, GetUniqueIdentifier, CheckReservedWord, AddReservedMapping, 
        CheckParameterName, CheckVariableDeclaratorName, CheckReservedWord, GetConstructorIndex, IsContinueExists, IsReturnExists, GetCaseLabelIndex, BuildCodeTemplateExpression, 
        AddCodeTemplateExpression, BuildCodeTemplateExpression, IsPropertyField, GetTypeDeclarationSymbol, IsInternalMember, BuildEmptyArray, GetConstLiteralExpression, GetConstLiteralExpression, 
        BuildStringLiteralTokenExpression, BuildStringLiteralExpression, BuildVerbatimStringExpression, __staticCtor__, __ctor__;
        __staticCtor__ = function (this) 
            codeTemplateRegex_ = System.Text.RegularExpressions.Regex([[(,?\s*)\{(\*?[\w|^]+)\}]], 8 --[[RegexOptions.Compiled]]);
        end;
        __ctor__ = function (this) 
            this.localReservedNames_ = System.Dictionary(Microsoft.CodeAnalysis.ISymbol, System.String)();
        end;
        IsLocalVarExists = function (this, name, root) 
            local searcher = CSharpLua.LuaSyntaxNodeTransfor.LocalVarSearcher(name);
            return searcher:Find(root);
        end;
        GetNewIdentifierName = function (this, name, index) 
            repeat
                local default = index;
                if default == 0 then
                    return name;
                elseif default == 1 then
                    return (name or "") .. "_";
                elseif default == 2 then
                    return "_" .. (name or "");
                else
                    return (name or "") .. (index - 2);
                end
            until 1;
        end;
        FindParent = function (this, node, macth) 
            local parent = node:getParent();
            while true do
                if macth(this, parent) then
                    return parent;
                end
                parent = parent:getParent();
            end
        end;
        FindParent = function (this, node, kind) 
            return FindParent(this, node, function (i) return IsKind(i, kind); end);
        end;
        GetUniqueIdentifier = function (this, name, node, index) 
            index = index or 0;
            local root = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax, FindParent(this, node, 8875 --[[SyntaxKind.MethodDeclaration]]));
            while true do
                local newName = GetNewIdentifierName(this, name, index);
                local exists = IsLocalVarExists(this, newName, root);
                if not exists then
                    return newName;
                end
                index = index + 1;
            end
        end;
        CheckReservedWord = function (this, name, node) 
            if CSharpLua.LuaAst.LuaSyntaxNode.IsReservedWord(name) then
                name = GetUniqueIdentifier(this, name, node, 1);
                AddReservedMapping(this, name, node);
                return true;
            end
            return false;
        end;
        AddReservedMapping = function (this, name, node) 
            local symbol = GetDeclaredSymbol(this.semanticModel_, node);
            assert(symbol ~= nil);
            this.localReservedNames_:Add(symbol, name);
        end;
        CheckParameterName = function (this, parameter, node) 
            local name = parameter.Identifier.ValueText;
            local default;
            default, name = CheckReservedWord(this, name, node);
            local isReserved = default;
            if isReserved then
                parameter = CSharpLua.LuaAst.LuaParameterSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name));
            end
        end;
        CheckVariableDeclaratorName = function (this, identifierName, node) 
            local name = identifierName.ValueText;
            local default;
            default, name = CheckReservedWord(this, name, node);
            local isReserved = default;
            if isReserved then
                identifierName = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
            end
        end;
        CheckReservedWord = function (this, name, symbol) 
            if CSharpLua.LuaAst.LuaSyntaxNode.IsReservedWord(name) then
                name = this.localReservedNames_:get(symbol);
            end
        end;
        GetConstructorIndex = function (this, constructorSymbol) 
            if IsFromCode(constructorSymbol) then
                local typeSymbol = System.cast(Microsoft.CodeAnalysis.INamedTypeSymbol, constructorSymbol:getReceiverType());
                if typeSymbol:getConstructors():getLength() > 1 then
                    local index = typeSymbol:getConstructors():IndexOf(constructorSymbol);
                    assert(index ~= - 1);
                    local ctroCounter = index + 1;
                    return ctroCounter;
                end
            end
            return 0;
        end;
        IsContinueExists = function (this, node) 
            local searcher = CSharpLua.LuaSyntaxNodeTransfor.ContinueSearcher();
            return searcher:Find(node);
        end;
        IsReturnExists = function (this, node) 
            local searcher = CSharpLua.LuaSyntaxNodeTransfor.ReturnStatementSearcher();
            return searcher:Find(node);
        end;
        GetCaseLabelIndex = function (this, node) 
            local switchStatement = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax, FindParent(this, node, 8821 --[[SyntaxKind.SwitchStatement]]));
            local index = 0;
            for _, section in System.each(switchStatement:getSections()) do
                local isFound = Linq.Any(section:getLabels(), function (i) 
                    if IsKind(i, 8823 --[[SyntaxKind.CaseSwitchLabel]]) then
                        local label = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax, i);
                        if label:getValue():ToString() == node:getExpression():ToString() then
                            return true;
                        end
                    end
                    return false;
                end);
                if isFound then
                    return index;
                end
            end
            System.throw(System.InvalidOperationException());
        end;
        BuildCodeTemplateExpression = function (this, codeTemplate, targetExpression) 
            return BuildCodeTemplateExpression(this, codeTemplate, targetExpression, System.Array.Empty(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax), System.Collections.Immutable.ImmutableArray_1(Microsoft.CodeAnalysis.ITypeSymbol).Empty);
        end;
        AddCodeTemplateExpression = function (this, expression, comma, codeTemplateExpression) 
            if not System.String.IsNullOrEmpty(comma) then
                codeTemplateExpression.Codes:Add(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, comma));
            end
            codeTemplateExpression.Codes:Add(expression);
        end;
        BuildCodeTemplateExpression = function (this, codeTemplate, targetExpression, arguments, typeArguments) 
            local codeTemplateExpression = CSharpLua.LuaAst.LuaCodeTemplateExpressionSyntax();

            local matchs = codeTemplateRegex_:Matches(codeTemplate);
            local prevIndex = 0;
            for _, match in System.each(matchs) do
                if match:getIndex() > prevIndex then
                    local prevToken = codeTemplate:Substring(prevIndex, match:getIndex() - prevIndex);
                    codeTemplateExpression.Codes:Add(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, prevToken));
                end
                local comma = match:getGroups():get(1):getValue();
                local key = match:getGroups():get(2):getValue();
                if key == "this" then
                    AddCodeTemplateExpression(this, BuildMemberAccessTargetExpression(this, targetExpression), comma, codeTemplateExpression);
                elseif key == "class" then
                    local type = GetTypeInfo(this.semanticModel_, targetExpression):getType();
                    local typeName = getXmlMetaProvider(this):GetTypeName(type);
                    AddCodeTemplateExpression(this, typeName, comma, codeTemplateExpression);
                elseif key:get(0) == 94 --[['^']] then
                    local typeIndex;
                    local default;
                    default, typeIndex = System.Int.TryParse(key:Substring(1), typeIndex);
                    if default then
                        local typeArgument = GetOrDefault(typeArguments, typeIndex, nil, Microsoft.CodeAnalysis.ITypeSymbol);
                        if typeArgument ~= nil then
                            local typeName = getXmlMetaProvider(this):GetTypeName(typeArgument);
                            AddCodeTemplateExpression(this, typeName, comma, codeTemplateExpression);
                        end
                    end
                elseif key:get(0) == 42 --[['*']] then
                    local paramsIndex;
                    local extern;
                    extern, paramsIndex = System.Int.TryParse(key:Substring(1), paramsIndex);
                    if extern then
                        local paramsExpression = CSharpLua.LuaAst.LuaCodeTemplateParamsExpressionSyntax();
                        for _, argument in System.each(Linq.Skip(arguments, paramsIndex)) do
                            local argumentExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, argument:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                            paramsExpression.Expressions:Add(argumentExpression);
                        end
                        if #paramsExpression.Expressions > 0 then
                            AddCodeTemplateExpression(this, paramsExpression, comma, codeTemplateExpression);
                        end
                    end
                else
                    local argumentIndex;
                    local ref;
                    ref, argumentIndex = System.Int.TryParse(key, argumentIndex);
                    if ref then
                        local argument = GetOrDefault(arguments, argumentIndex, nil, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax);
                        if argument ~= nil then
                            local argumentExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, argument:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                            AddCodeTemplateExpression(this, argumentExpression, comma, codeTemplateExpression);
                        end
                    end
                end
                prevIndex = match:getIndex() + match:getLength();
            end

            if prevIndex < #codeTemplate then
                local last = codeTemplate:Substring(prevIndex);
                codeTemplateExpression.Codes:Add(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, last));
            end

            return codeTemplateExpression;
        end;
        IsPropertyField = function (this, symbol) 
            return IsPropertyField(symbol) or getXmlMetaProvider(this):IsPropertyField(symbol);
        end;
        GetTypeDeclarationSymbol = function (this, node) 
            local typeDeclaration = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax, FindParent(this, node, function (i) return IsKind(i, 8855 --[[SyntaxKind.ClassDeclaration]]) or IsKind(i, 8856 --[[SyntaxKind.StructDeclaration]]); end));
            return GetDeclaredSymbol(this.semanticModel_, typeDeclaration);
        end;
        IsInternalMember = function (this, node, symbol) 
            local isVirtual = IsOverridable(symbol) and not symbol:getContainingType():getIsSealed();
            if not isVirtual then
                local typeSymbol = GetTypeDeclarationSymbol(this, node);
                if typeSymbol == symbol:getContainingType() then
                    return true;
                end
            end
            return false;
        end;
        BuildEmptyArray = function (this, baseType) 
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLua.LuaAst.LuaIdentifierNameSyntax.ArrayEmpty, baseType);
        end;
        GetConstLiteralExpression = function (this, constantValue) 
            if constantValue ~= nil then
                local code = System.Type.GetTypeCode(constantValue:GetType());
                repeat
                    local default = code;
                    if default == 4 --[[TypeCode.Char]] then
                        
                            return CSharpLua.LuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constantValue));
                        elseif default == 18 --[[TypeCode.String]] then
                        
                            return BuildStringLiteralExpression(this, System.cast(System.String, constantValue));
                        else
                        
                            return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, constantValue:ToString());
                        end
                until 1;
            else
                return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(2, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Nil);
            end
        end;
        GetConstLiteralExpression = function (this, constField) 
            assert(constField:getHasConstantValue());
            if constField:getType():getSpecialType() == 8 --[[SpecialType.System_Char]] then
                return CSharpLua.LuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, constField:getConstantValue()));
            else
                local constExpression = GetConstLiteralExpression(this, constField:getConstantValue());
                local identifierToken = (constField:getContainingType():getName() or "") .. '.' .. (constField:getName() or "");
                return CSharpLua.LuaAst.LuaConstLiteralExpression:new(2, constExpression, identifierToken);
            end
        end;
        BuildStringLiteralTokenExpression = function (this, token) 
            if token:getText():get(0) == 64 --[['@']] then
                return BuildVerbatimStringExpression(this, token:getValueText());
            else
                return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, token:getText());
            end
        end;
        BuildStringLiteralExpression = function (this, value) 
            local text = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(value):getText();
            return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, text);
        end;
        BuildVerbatimStringExpression = function (this, value) 
            local kCloseBracket = "]" --[[Tokens.CloseBracket]];
            local equals = "=" --[[Tokens.Equals]]:get(0);
            local count = 0;
            while true do
                local closeToken = kCloseBracket .. (System.String(equals, count) or "") .. kCloseBracket;
                if not value:Contains(closeToken) then
                    break;
                end
                count = count + 1;
            end
            if value:get(0) == 10 --[['\n']] then
                value = '\n' .. (value or "");
            end
            return CSharpLua.LuaAst.LuaVerbatimStringLiteralExpressionSyntax(value, count);
        end;
        return {
            localMappingCounter_ = 0, 
            __staticCtor__ = __staticCtor__, 
            __ctor__ = __ctor__
        };
    end);
end);
