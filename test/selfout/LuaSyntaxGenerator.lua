-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua", function (namespace) 
    namespace.class("PartialTypeDeclaration", function (namespace) 
        local CompareTo;
        CompareTo = function (this, other) 
            return #this.CompilationUnit.FilePath:CompareTo(#other.CompilationUnit.FilePath);
        end;
        return {
            __inherits__ = {
                System.IComparable_1(CSharpLua.PartialTypeDeclaration)
            }, 
            CompareTo = CompareTo
        };
    end);
    namespace.class("LuaSyntaxGenerator", function (namespace) 
        namespace.class("SettingInfo", function (namespace) 
            local getIndent, setIndent, __ctor__;
            getIndent = function (this) 
                return this.indent_;
            end;
            setIndent = function (this, value) 
                if this.indent_ ~= value then
                    this.indent_ = value;
                    this.IndentString = System.String(32 --[[' ']], this.indent_);
                end
            end;
            __ctor__ = function (this) 
                setIndent(this, 4);
                this.HasSemicolon = true;
                this.IsNewest = true;
            end;
            return {
                HasSemicolon = False, 
                indent_ = 0, 
                IsNewest = False, 
                getIndent = getIndent, 
                setIndent = setIndent, 
                __ctor__ = __ctor__
            };
        end);
        local Create, Generate, IsEnumExport, AddExportEnum, AddPartialTypeDeclaration, CheckPartialTypes, GetSemanticModel, IsBaseType, 
        __init__, __ctor__;
        Create = function (this) 
            local luaCompilationUnits = System.List(CSharpLua.LuaAst.LuaCompilationUnitSyntax)();
            for _, syntaxTree in System.each(this.compilation_:getSyntaxTrees()) do
                local semanticModel = GetSemanticModel(this, syntaxTree);
                local compilationUnitSyntax = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax, syntaxTree:GetRoot());
                local transfor = CSharpLua.LuaSyntaxNodeTransfor:new(1, this, semanticModel);
                local luaCompilationUnit = System.cast(CSharpLua.LuaAst.LuaCompilationUnitSyntax, compilationUnitSyntax:Accept(transfor, CSharpLua.LuaAst.LuaSyntaxNode));
                luaCompilationUnits:Add(luaCompilationUnit);
            end
            CheckPartialTypes(this);
            return Linq.Where(luaCompilationUnits, function (i) return not i:getIsEmpty(); end);
        end;
        Generate = function (this, writerFunctor) 
            for _, luaCompilationUnit in System.each(Create(this)) do
                System.using(function (writer) 
                    local rener = CSharpLua.LuaRenderer(this, writer);
                    luaCompilationUnit:Render(rener);
                end, writerFunctor(this, luaCompilationUnit));
            end
        end;
        IsEnumExport = function (this, enumName) 
            return this.exportEnums_:Contains(enumName);
        end;
        AddExportEnum = function (this, enumName) 
            this.exportEnums_:Add(enumName);
        end;
        AddPartialTypeDeclaration = function (this, typeSymbol, node, luaNode, compilationUnit) 
            local list = CSharpLua.Utility.GetOrDefault(this.partialTypes_, typeSymbol, nil, Microsoft.CodeAnalysis.INamedTypeSymbol, System.List(T));
            if list == nil then
                list = System.List(CSharpLua.PartialTypeDeclaration)();
                this.partialTypes_:Add(typeSymbol, list);
            end
            list:Add(System.create(CSharpLua.PartialTypeDeclaration(), function (default) 
                default.Symbol = typeSymbol;
                default.Node = node;
                default.LuaNode = luaNode;
                default.CompilationUnit = compilationUnit;
            end));
        end;
        CheckPartialTypes = function (this) 
            for _, typeDeclarations in System.each(this.partialTypes_:getValues()) do
                local major = Linq.Min(typeDeclarations);
                local transfor = CSharpLua.LuaSyntaxNodeTransfor:new(1, this, nil);
                transfor:AcceptPartialType(major, typeDeclarations);
            end
        end;
        GetSemanticModel = function (this, syntaxTree) 
            return this.compilation_:GetSemanticModel(syntaxTree);
        end;
        IsBaseType = function (this, type) 
            local syntaxTree = type:getSyntaxTree();
            local semanticModel = GetSemanticModel(this, syntaxTree);
            local symbol = Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(semanticModel, type:getType()):getType();
            assert(symbol ~= nil);
            return symbol:getTypeKind() ~= 7 --[[TypeKind.Interface]];
        end;
        __init__ = function (this) 
            this.exportEnums_ = System.HashSet(System.String)();
            this.partialTypes_ = System.Dictionary(Microsoft.CodeAnalysis.INamedTypeSymbol, System.List(CSharpLua.PartialTypeDeclaration))();
        end;
        __ctor__ = function (this, metas, compilation) 
            __init__(this);
            this.XmlMetaProvider = CSharpLua.XmlMetaProvider(metas);
            this.Setting = CSharpLua.LuaSyntaxGenerator.SettingInfo();
            this.compilation_ = compilation;
        end;
        return {
            Generate = Generate, 
            IsEnumExport = IsEnumExport, 
            AddExportEnum = AddExportEnum, 
            AddPartialTypeDeclaration = AddPartialTypeDeclaration, 
            GetSemanticModel = GetSemanticModel, 
            IsBaseType = IsBaseType, 
            __ctor__ = __ctor__
        };
    end);
end);
