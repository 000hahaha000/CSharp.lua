-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua", function (namespace) 
    namespace.class("PartialTypeDeclaration", function (namespace) 
        local CompareTo;
        CompareTo = function (this, other) 
            return #this.CompilationUnit.FilePath:CompareTo(#other.CompilationUnit.FilePath);
        end;
        return {
            __inherits__ = {
                System.IComparable_1(CSharpLua.PartialTypeDeclaration)
            }, 
            CompareTo = CompareTo
        };
    end);
    namespace.class("LuaSyntaxGenerator", function (namespace) 
        namespace.class("SettingInfo", function (namespace) 
            local getIndent, setIndent, __ctor__;
            getIndent = function (this) 
                return this.indent_;
            end;
            setIndent = function (this, value) 
                if this.indent_ ~= value then
                    this.indent_ = value;
                    this.IndentString = System.String(32 --[[' ']], this.indent_);
                end
            end;
            __ctor__ = function (this) 
                setIndent(this, 4);
                this.HasSemicolon = true;
                this.IsNewest = true;
            end;
            return {
                HasSemicolon = False, 
                indent_ = 0, 
                IsNewest = False, 
                getIndent = getIndent, 
                setIndent = setIndent, 
                __ctor__ = __ctor__
            };
        end);
        local Create, Generate, IsEnumExport, AddExportEnum, AddPartialTypeDeclaration, CheckPartialTypes, GetSemanticModel, IsBaseType, 
        GetMethodName, InternalGetMethodName, GetSameNameMembers, FillSameNameMembers, __init__, __ctor__;
        Create = function (this) 
            local luaCompilationUnits = System.List(CSharpLua.LuaAst.LuaCompilationUnitSyntax)();
            for _, syntaxTree in System.each(this.compilation_:getSyntaxTrees()) do
                local semanticModel = GetSemanticModel(this, syntaxTree);
                local compilationUnitSyntax = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax, syntaxTree:GetRoot());
                local transfor = CSharpLua.LuaSyntaxNodeTransfor:new(1, this, semanticModel);
                local luaCompilationUnit = System.cast(CSharpLua.LuaAst.LuaCompilationUnitSyntax, compilationUnitSyntax:Accept(transfor, CSharpLua.LuaAst.LuaSyntaxNode));
                luaCompilationUnits:Add(luaCompilationUnit);
            end
            CheckPartialTypes(this);
            return Linq.Where(luaCompilationUnits, function (i) return not i:getIsEmpty(); end);
        end;
        Generate = function (this, writerFunctor) 
            for _, luaCompilationUnit in System.each(Create(this)) do
                System.using(function (writer) 
                    local rener = CSharpLua.LuaRenderer(this, writer);
                    luaCompilationUnit:Render(rener);
                end, writerFunctor(this, luaCompilationUnit));
            end
        end;
        IsEnumExport = function (this, enumName) 
            return this.exportEnums_:Contains(enumName);
        end;
        AddExportEnum = function (this, enumName) 
            this.exportEnums_:Add(enumName);
        end;
        AddPartialTypeDeclaration = function (this, typeSymbol, node, luaNode, compilationUnit) 
            local list = CSharpLua.Utility.GetOrDefault1(this.partialTypes_, typeSymbol, nil, Microsoft.CodeAnalysis.INamedTypeSymbol, System.List(T));
            if list == nil then
                list = System.List(CSharpLua.PartialTypeDeclaration)();
                this.partialTypes_:Add(typeSymbol, list);
            end
            list:Add(System.create(CSharpLua.PartialTypeDeclaration(), function (default) 
                default.Symbol = typeSymbol;
                default.Node = node;
                default.LuaNode = luaNode;
                default.CompilationUnit = compilationUnit;
            end));
        end;
        CheckPartialTypes = function (this) 
            for _, typeDeclarations in System.each(this.partialTypes_:getValues()) do
                local major = Linq.Min(typeDeclarations);
                local transfor = CSharpLua.LuaSyntaxNodeTransfor:new(1, this, nil);
                transfor:AcceptPartialType(major, typeDeclarations);
            end
        end;
        GetSemanticModel = function (this, syntaxTree) 
            return this.compilation_:GetSemanticModel(syntaxTree);
        end;
        IsBaseType = function (this, type) 
            local syntaxTree = type:getSyntaxTree();
            local semanticModel = GetSemanticModel(this, syntaxTree);
            local symbol = Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(semanticModel, type:getType()):getType();
            assert(symbol ~= nil);
            return symbol:getTypeKind() ~= 7 --[[TypeKind.Interface]];
        end;
        GetMethodName = function (this, symbol) 
            local name = CSharpLua.Utility.GetOrDefault1(this.methodNamesCache_, symbol, nil, Microsoft.CodeAnalysis.IMethodSymbol, CSharpLua.LuaAst.LuaIdentifierNameSyntax);
            if name == nil then
                name = InternalGetMethodName(this, symbol);
                this.methodNamesCache_:Add(symbol, name);
            end
            return name;
        end;
        InternalGetMethodName = function (this, symbol) 
            local name = this.XmlMetaProvider:GetMethodMapName(symbol);
            if name ~= nil then
                return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
            end

            if not CSharpLua.Utility.IsFromCode(symbol) then
                return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName());
            end

            local methods = GetSameNameMembers(this, symbol:getContainingType(), symbol:getName());
            if #methods == 1 then
                return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName());
            else
                if symbol:getIsExtensionMethod() then
                    if symbol:getReducedFrom() ~= nil then
                        symbol = symbol:getReducedFrom();
                    end
                elseif symbol:getIsOverride() then
                    if symbol:getOverriddenMethod() ~= nil then
                        symbol = symbol:getOverriddenMethod();
                    end
                end

                local index = methods:IndexOf(symbol);
                assert(index ~= - 1);
                if index == 0 then
                    return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName());
                else
                    return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, (symbol:getName() or "") .. index);
                end
            end
        end;
        GetSameNameMembers = function (this, typeSymbol, name) 
            local members = System.List(Microsoft.CodeAnalysis.ISymbol)();
            FillSameNameMembers(this, typeSymbol, name, members);
            return members;
        end;
        FillSameNameMembers = function (this, typeSymbol, name, outList) 
            if typeSymbol:getBaseType() ~= nil then
                FillSameNameMembers(this, typeSymbol:getBaseType(), name, outList);
            end

            local isFromCode = CSharpLua.Utility.IsFromCode(typeSymbol);
            local members = typeSymbol:GetMembers(name);
            for _, member in System.each(members) do
                local continue;
                repeat
                    if not isFromCode then
                        if member:getDeclaredAccessibility() == 1 --[[Accessibility.Private]] or member:getDeclaredAccessibility() == 4 --[[Accessibility.Internal]] then
                            continue = true;
                            break;
                        end
                    end

                    if member:getIsOverride() then
                        continue = true;
                        break;
                    end

                    outList:Add(member);
                    continue = true;
                until 1;
                if not continue then
                    break;
                end
            end
        end;
        __init__ = function (this) 
            this.exportEnums_ = System.HashSet(System.String)();
            this.partialTypes_ = System.Dictionary(Microsoft.CodeAnalysis.INamedTypeSymbol, System.List(CSharpLua.PartialTypeDeclaration))();
            this.methodNamesCache_ = System.Dictionary(Microsoft.CodeAnalysis.IMethodSymbol, CSharpLua.LuaAst.LuaIdentifierNameSyntax)();
        end;
        __ctor__ = function (this, metas, compilation) 
            __init__(this);
            this.XmlMetaProvider = CSharpLua.XmlMetaProvider(metas);
            this.Setting = CSharpLua.SettingInfo();
            this.compilation_ = compilation;
        end;
        return {
            Generate = Generate, 
            IsEnumExport = IsEnumExport, 
            AddExportEnum = AddExportEnum, 
            AddPartialTypeDeclaration = AddPartialTypeDeclaration, 
            GetSemanticModel = GetSemanticModel, 
            IsBaseType = IsBaseType, 
            GetMethodName = GetMethodName, 
            __ctor__ = __ctor__
        };
    end);
end);
