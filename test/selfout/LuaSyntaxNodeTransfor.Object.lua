-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua", function (namespace) 
    namespace.class("LuaSyntaxNodeTransfor", function (namespace) 
        local VisitObjectCreationExpression, BuildObjectInitializerExpression, VisitInitializerExpression, VisitBracketedArgumentList, VisitImplicitElementAccess, VisitGenericName, VisitOmittedArraySizeExpression, VisitArrayRankSpecifier, 
        VisitArrayType, FillMultiArrayInitializer, VisitArrayCreationExpression, VisitConstructorDeclaration, VisitSimpleBaseType, VisitLambdaExpression, VisitSimpleLambdaExpression, VisitParenthesizedLambdaExpression, 
        VisitTypeParameter, VisitTypeOfExpression, VisitThrowStatement, VisitCatchFilterClause, VisitCatchClause, VisitCatchDeclaration, VisitTryCatchesExpress, BuildCheckReturnInvocationExpression, 
        VisitFinallyClause, VisitTryStatement, VisitUsingStatement, VisitThisExpression, IsBaseEnable, VisitBaseExpression, VisitConditionalAccessExpression, VisitMemberBindingExpression, 
        VisitDefaultExpression, VisitElementAccessExpression, VisitInterpolatedStringExpression, VisitInterpolation, VisitInterpolatedStringText;
        VisitObjectCreationExpression = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));

            local symbol = System.cast(Microsoft.CodeAnalysis.IMethodSymbol, GetSymbolInfo(this.semanticModel_, node):getSymbol());
            local index = GetConstructorIndex(this, symbol);
            if index > 0 then
                expression = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, CSharpLua.LuaAst.LuaIdentifierNameSyntax.New, true);
            end

            local argumentList = System.cast(CSharpLua.LuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local invocationExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, expression);
            if index > 0 then
                invocationExpression:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(2, index));
            end
            invocationExpression.ArgumentList.Arguments:AddRange(argumentList.Arguments);
            if node:getInitializer() == nil then
                return invocationExpression;
            else
                local functionExpression = System.cast(CSharpLua.LuaAst.LuaFunctionExpressionSyntax, node:getInitializer():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Create, invocationExpression, functionExpression);
            end
        end;
        BuildObjectInitializerExpression = function (this, node) 
            local function_ = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, function_);
            local temp = GetTempIdentifier(this, node);
            function_:AddParameter(temp);
            for _, expression in System.each(node:getExpressions()) do
                if IsKind(expression, 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
                    local assignment = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax, expression);
                    local left = assignment:getLeft():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
                    local right = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, assignment:getRight():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));

                    if IsKind(assignment:getLeft(), 8656 --[[SyntaxKind.ImplicitElementAccess]]) then
                        local argumentList = System.cast(CSharpLua.LuaAst.LuaArgumentListSyntax, left);
                        local methodName = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, "set" --[[Tokens.Set]]);
                        local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(temp, methodName, true);
                        local invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
                        invocation.ArgumentList.Arguments:AddRange(argumentList.Arguments);
                        invocation:AddArgument(right);
                        function_.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(invocation));
                    else
                        local identifierName = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, left);
                        local newIdentifier = identifierName.ValueText:Replace(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This.ValueText, temp.ValueText);
                        identifierName = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, newIdentifier);
                        function_.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(identifierName, right)));
                    end
                else
                    local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(temp, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Add, true);
                    local value = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    function_.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, value)));
                end
            end

            PopFunction(this);
            return function_;
        end;
        VisitInitializerExpression = function (this, node) 
            if not IsKind(node, 8646 --[[SyntaxKind.ArrayInitializerExpression]]) then
                return BuildObjectInitializerExpression(this, node);
            else
                local symbol = System.cast(Microsoft.CodeAnalysis.IArrayTypeSymbol, GetTypeInfo(this.semanticModel_, node):getConvertedType());
                if node:getExpressions():getCount() > 0 then
                    local arrayType = getXmlMetaProvider(this):GetTypeName(symbol);
                    local invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, arrayType);
                    for _, expression in System.each(node:getExpressions()) do
                        local element = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        invocation:AddArgument(element);
                    end
                    return invocation;
                else
                    local baseType = getXmlMetaProvider(this):GetTypeName(symbol:getElementType());
                    return BuildEmptyArray(this, baseType);
                end
            end
        end;
        VisitBracketedArgumentList = function (this, node) 
            return BuildArgumentList(this, node:getArguments());
        end;
        VisitImplicitElementAccess = function (this, node) 
            return node:getArgumentList():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
        end;
        VisitGenericName = function (this, node) 
            local symbolInfo = GetSymbolInfo(this.semanticModel_, node);
            local symbol = symbolInfo:getSymbol();
            if symbol:getKind() == 9 --[[SymbolKind.Method]] then
                return GetMethodNameExpression(this, System.cast(Microsoft.CodeAnalysis.IMethodSymbol, symbol), node);
            else
                local name = getXmlMetaProvider(this):GetTypeShortName(symbol);
                return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(5, name, Linq.Select(node:getTypeArgumentList():getArguments(), function (i) return System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode)); end, CSharpLua.LuaAst.LuaExpressionSyntax));
            end
        end;
        VisitOmittedArraySizeExpression = function (this, node) 
            return nil;
        end;
        VisitArrayRankSpecifier = function (this, node) 
            local rankSpecifier = CSharpLua.LuaAst.LuaArrayRankSpecifierSyntax(node:getRank());
            for _, size in System.each(node:getSizes()) do
                local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, size:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                rankSpecifier.Sizes:Add(expression);
            end
            return rankSpecifier;
        end;
        VisitArrayType = function (this, node) 
            local elementType = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getElementType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));

            local typeExpress = nil;
            for _, rank in System.each(Linq.Reverse(node:getRankSpecifiers())) do
                local default;
                if rank:getRank() == 1 then
                    default = CSharpLua.LuaAst.LuaIdentifierNameSyntax.Array;
                else
                    default = CSharpLua.LuaAst.LuaIdentifierNameSyntax.MultiArray;
                end
                local arrayTypeName = default;
                typeExpress = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, arrayTypeName, typeExpress or elementType);
            end

            local arrayRankSpecifier = System.cast(CSharpLua.LuaAst.LuaArrayRankSpecifierSyntax, node:getRankSpecifiers():get(0):Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local arrayTypeAdapter = CSharpLua.LuaAst.LuaArrayTypeAdapterExpressionSyntax(typeExpress, arrayRankSpecifier);
            return arrayTypeAdapter;
        end;
        FillMultiArrayInitializer = function (this, initializer, rankSpecifier, invocation, isFirst) 
            if isFirst then
                rankSpecifier.Items:Add(CSharpLua.LuaAst.LuaSingleTableItemSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(2, initializer:getExpressions():getCount())));
            end

            local index = 0;
            for _, expression in System.each(initializer:getExpressions()) do
                if IsKind(expression, 8646 --[[SyntaxKind.ArrayInitializerExpression]]) then
                    FillMultiArrayInitializer(this, System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax, expression), rankSpecifier, invocation, index == 0);
                else
                    local item = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    invocation:AddArgument(item);
                end
                index = index + 1;
            end
        end;
        VisitArrayCreationExpression = function (this, node) 
            local arrayType = System.cast(CSharpLua.LuaAst.LuaArrayTypeAdapterExpressionSyntax, node:getType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            if node:getInitializer() ~= nil and node:getInitializer():getExpressions():getCount() > 0 then
                if arrayType:getIsSimapleArray() then
                    return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(5, arrayType, Linq.Select(node:getInitializer():getExpressions(), function (i) return System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode)); end, CSharpLua.LuaAst.LuaExpressionSyntax));
                else
                    local rankSpecifier = CSharpLua.LuaAst.LuaTableInitializerExpression();
                    local invocationExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, arrayType, rankSpecifier);
                    FillMultiArrayInitializer(this, node:getInitializer(), rankSpecifier, invocationExpression, true);
                    return invocationExpression;
                end
            else
                if arrayType:getIsSimapleArray() then
                    local size = arrayType.RankSpecifier.Sizes:get(0);
                    if size == nil then
                        return BuildEmptyArray(this, arrayType:getBaseType());
                    end

                    local constSize = System.as(size, CSharpLua.LuaAst.LuaLiteralExpressionSyntax);
                    if constSize ~= nil and constSize:getText() == (0):ToString() then
                        return BuildEmptyArray(this, arrayType:getBaseType());
                    end

                    local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(arrayType, CSharpLua.LuaAst.LuaIdentifierNameSyntax.New, true);
                    return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, size);
                else
                    local rankSpecifier = CSharpLua.LuaAst.LuaTableInitializerExpression();
                    for _, size in System.each(arrayType.RankSpecifier.Sizes) do
                        if size ~= nil then
                            rankSpecifier.Items:Add(CSharpLua.LuaAst.LuaSingleTableItemSyntax(size));
                        else
                            rankSpecifier.Items:Add(CSharpLua.LuaAst.LuaSingleTableItemSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(2, 0)));
                        end
                    end
                    return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, arrayType, rankSpecifier);
                end
            end
        end;
        VisitConstructorDeclaration = function (this, node) 
            local function_ = CSharpLua.LuaAst.LuaConstructorAdapterExpressionSyntax();
            PushFunction(this, function_);
            local isStatic = IsStatic(node:getModifiers());
            function_.IsStaticCtor = isStatic;
            local parameterList = System.cast(CSharpLua.LuaAst.LuaParameterListSyntax, node:getParameterList():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            function_:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
            function_.ParameterList.Parameters:AddRange(parameterList.Parameters);
            if node:getInitializer() ~= nil then
                local symbol = System.cast(Microsoft.CodeAnalysis.IMethodSymbol, GetSymbolInfo(this.semanticModel_, node:getInitializer()):getSymbol());
                local ctroCounter = GetConstructorIndex(this, symbol);
                local otherCtorInvoke;
                if IsKind(node:getInitializer(), 8890 --[[SyntaxKind.ThisConstructorInitializer]]) then
                    assert(ctroCounter ~= 0);
                    local thisCtor = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, CSharpLua.LuaAst.LuaSyntaxNode.SpecailWord("ctor" --[[Tokens.Ctor]] .. ctroCounter));
                    otherCtorInvoke = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, thisCtor);
                    function_.IsInvokeThisCtor = true;
                else
                    local typeName = getXmlMetaProvider(this):GetTypeName(symbol:getReceiverType());
                    local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(typeName, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Ctor);
                    if ctroCounter > 0 then
                        otherCtorInvoke = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaTableIndexAccessExpressionSyntax(memberAccess, CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(2, ctroCounter)));
                    else
                        otherCtorInvoke = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
                    end
                end

                otherCtorInvoke:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                local argumentList = System.cast(CSharpLua.LuaAst.LuaArgumentListSyntax, node:getInitializer():getArgumentList():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                otherCtorInvoke.ArgumentList.Arguments:AddRange(argumentList.Arguments);
                function_.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(otherCtorInvoke));
            end
            local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, node:getBody():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            function_.Body.Statements:AddRange(block.Statements);
            PopFunction(this);
            if isStatic then
                getCurType(this):SetStaticCtor(function_);
            else
                getCurType(this):AddCtor(function_);
            end
            return function_;
        end;
        VisitSimpleBaseType = function (this, node) 
            return node:getType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
        end;
        VisitLambdaExpression = function (this, parameters, body) 
            local function_ = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, function_);

            for _, parameter in System.each(parameters) do
                local luaParameter = System.cast(CSharpLua.LuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                function_.ParameterList.Parameters:Add(luaParameter);
            end

            local resultExpression = function_;
            if IsKind(body, 8792 --[[SyntaxKind.Block]]) then
                local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, body:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                function_.Body.Statements:AddRange(block.Statements);
            else
                this.blocks_:Push(function_.Body);
                local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, body:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                this.blocks_:Pop();
                function_.Body.Statements:Add(CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, expression));
                if #function_.Body.Statements == 1 then
                    resultExpression = CSharpLua.LuaAst.LuaSimpleLambdaAdapterExpression(function_);
                end
            end

            PopFunction(this);
            return resultExpression;
        end;
        VisitSimpleLambdaExpression = function (this, node) 
            return VisitLambdaExpression(this, System.Array(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)(node:getParameter()), node:getBody());
        end;
        VisitParenthesizedLambdaExpression = function (this, node) 
            return VisitLambdaExpression(this, node:getParameterList():getParameters(), node:getBody());
        end;
        VisitTypeParameter = function (this, node) 
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
        end;
        VisitTypeOfExpression = function (this, node) 
            local typeName = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, node:getType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLua.LuaAst.LuaIdentifierNameSyntax.TypeOf, typeName);
        end;
        VisitThrowStatement = function (this, node) 
            local invocationExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Throw);
            if node:getExpression() ~= nil then
                local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                invocationExpression:AddArgument(expression);
            else
                local curTryFunction = System.cast(CSharpLua.LuaAst.LuaTryAdapterExpressionSyntax, getCurFunction(this));
                assert(curTryFunction.CatchTemp ~= nil);
                invocationExpression:AddArgument(curTryFunction.CatchTemp);
            end
            return CSharpLua.LuaAst.LuaExpressionStatementSyntax(invocationExpression);
        end;
        VisitCatchFilterClause = function (this, node) 
            return node:getFilterExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
        end;
        VisitCatchClause = function (this, node) 
            System.throw(System.InvalidOperationException());
        end;
        VisitCatchDeclaration = function (this, node) 
            return CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText()));
        end;
        VisitTryCatchesExpress = function (this, catches) 
            local functionExpress = CSharpLua.LuaAst.LuaTryAdapterExpressionSyntax();
            PushFunction(this, functionExpress);
            local temp = GetTempIdentifier(this, catches:First());
            functionExpress.CatchTemp = temp;
            functionExpress:AddParameter(temp);

            local ifHeadStatement = nil;
            local ifTailStatement = nil;
            local hasCatchRoot = false;
            for _, catchNode in System.each(catches) do
                local isRootExceptionDeclaration = false;
                local ifCondition = nil;
                if catchNode:getFilter() ~= nil then
                    ifCondition = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, catchNode:getFilter():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                end
                if catchNode:getDeclaration() ~= nil then
                    local typeName = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, catchNode:getDeclaration():getType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    if typeName.ValueText ~= "System.Exception" then
                        local mathcTypeInvocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Is, temp, typeName);
                        if ifCondition ~= nil then
                            ifCondition = CSharpLua.LuaAst.LuaBinaryExpressionSyntax(ifCondition, "and" --[[Keyword.And]], mathcTypeInvocation);
                        else
                            ifCondition = mathcTypeInvocation;
                        end
                    else
                        if not IsKind(catchNode:getDeclaration():getIdentifier(), 0 --[[SyntaxKind.None]]) then
                            isRootExceptionDeclaration = true;
                        end
                        hasCatchRoot = true;
                    end
                else
                    hasCatchRoot = true;
                end

                local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, catchNode:getBlock():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                if ifCondition ~= nil then
                    local statement = CSharpLua.LuaAst.LuaIfStatementSyntax(ifCondition);
                    if catchNode:getDeclaration() ~= nil and not IsKind(catchNode:getDeclaration():getIdentifier(), 0 --[[SyntaxKind.None]]) then
                        local variableDeclarator = System.cast(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax, catchNode:getDeclaration():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        variableDeclarator.Initializer = CSharpLua.LuaAst.LuaEqualsValueClauseSyntax(temp);
                        statement.Body.Statements:Add(CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(variableDeclarator));
                    end
                    statement.Body.Statements:AddRange(block.Statements);
                    if ifTailStatement ~= nil then
                        ifTailStatement.Else = CSharpLua.LuaAst.LuaElseClauseSyntax(statement);
                    else
                        ifHeadStatement = statement;
                    end
                    ifTailStatement = statement;
                else
                    if isRootExceptionDeclaration then
                        local variableDeclarator = System.cast(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax, catchNode:getDeclaration():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        variableDeclarator.Initializer = CSharpLua.LuaAst.LuaEqualsValueClauseSyntax(temp);
                        block.Statements:Insert(0, CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(variableDeclarator));
                    end

                    if ifTailStatement ~= nil then
                        ifTailStatement.Else = CSharpLua.LuaAst.LuaElseClauseSyntax(block);
                    else
                        functionExpress.Body.Statements:AddRange(block.Statements);
                    end
                    break;
                end
            end

            if ifHeadStatement ~= nil then
                if not hasCatchRoot then
                    assert(ifTailStatement.Else == nil);
                    local rethrowStatement = CSharpLua.LuaAst.LuaMultipleReturnStatementSyntax();
                    rethrowStatement.Expressions:Add(CSharpLua.LuaAst.LuaIdentifierNameSyntax.One);
                    rethrowStatement.Expressions:Add(temp);
                    local block = CSharpLua.LuaAst.LuaBlockSyntax();
                    block.Statements:Add(rethrowStatement);
                    ifTailStatement.Else = CSharpLua.LuaAst.LuaElseClauseSyntax(block);
                end
                functionExpress.Body.Statements:Add(ifHeadStatement);
            end

            PopFunction(this);
            return functionExpress;
        end;
        BuildCheckReturnInvocationExpression = function (this, invocationExpression, node) 
            if IsReturnExists(this, node) then
                local temp1 = GetTempIdentifier(this, node);
                local temp2 = GetTempIdentifier(this, node);
                local localVariables = CSharpLua.LuaAst.LuaLocalVariablesStatementSyntax();
                localVariables.Variables:Add(temp1);
                localVariables.Variables:Add(temp2);
                local initializer = CSharpLua.LuaAst.LuaEqualsValueClauseListSyntax();
                initializer.Values:Add(invocationExpression);
                localVariables.Initializer = initializer;

                local ifStatement = CSharpLua.LuaAst.LuaIfStatementSyntax(temp1);
                if System.is(getCurFunction(this), CSharpLua.LuaAst.LuaCheckReturnFunctionExpressionSyntax) then
                    local returnStatement = CSharpLua.LuaAst.LuaMultipleReturnStatementSyntax();
                    returnStatement.Expressions:Add(CSharpLua.LuaAst.LuaIdentifierNameSyntax.True);
                    returnStatement.Expressions:Add(temp2);
                    ifStatement.Body.Statements:Add(returnStatement);
                else
                    ifStatement.Body.Statements:Add(CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, temp2));
                end

                local statements = CSharpLua.LuaAst.LuaStatementListSyntax();
                statements.Statements:Add(localVariables);
                statements.Statements:Add(ifStatement);
                return statements;
            else
                return CSharpLua.LuaAst.LuaExpressionStatementSyntax(invocationExpression);
            end
        end;
        VisitFinallyClause = function (this, node) 
            local functionExpress = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, functionExpress);
            local finallyBlock = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, node:getBlock():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            PopFunction(this);
            functionExpress.Body.Statements:AddRange(finallyBlock.Statements);
            return functionExpress;
        end;
        VisitTryStatement = function (this, node) 
            local tryInvocationExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Try);

            local tryBlockFunctionExpress = CSharpLua.LuaAst.LuaTryAdapterExpressionSyntax();
            PushFunction(this, tryBlockFunctionExpress);
            local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, node:getBlock():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            PopFunction(this);
            tryBlockFunctionExpress.Body.Statements:AddRange(block.Statements);
            tryInvocationExpression:AddArgument(tryBlockFunctionExpress);

            if node:getCatches():getCount() > 0 then
                local catchesExpress = VisitTryCatchesExpress(this, node:getCatches());
                tryInvocationExpression:AddArgument(catchesExpress);
            else
                tryInvocationExpression:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.Nil);
            end

            if node:getFinally() ~= nil then
                local finallyfunctionExpress = System.cast(CSharpLua.LuaAst.LuaFunctionExpressionSyntax, node:getFinally():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                tryInvocationExpression:AddArgument(finallyfunctionExpress);
            end

            return BuildCheckReturnInvocationExpression(this, tryInvocationExpression, node);
        end;
        VisitUsingStatement = function (this, node) 
            local usingInvocationExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Using);

            local variableIdentifiers = System.List(CSharpLua.LuaAst.LuaIdentifierNameSyntax)();
            local variableExpressions = System.List(CSharpLua.LuaAst.LuaExpressionSyntax)();
            if node:getDeclaration() ~= nil then
                local variableList = System.cast(CSharpLua.LuaAst.LuaVariableListDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                for _, variable in System.each(variableList.Variables) do
                    variableIdentifiers:Add(variable.Identifier);
                    variableExpressions:Add(variable.Initializer.Value);
                end
            else
                local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                variableExpressions:Add(expression);
            end

            local usingAdapterExpress = CSharpLua.LuaAst.LuaUsingAdapterExpressionSyntax();
            usingAdapterExpress.ParameterList.Parameters:AddRange(Linq.Select(variableIdentifiers, function (i) return CSharpLua.LuaAst.LuaParameterSyntax(i); end, CSharpLua.LuaAst.LuaParameterSyntax));
            PushFunction(this, usingAdapterExpress);
            WriteStatementOrBlock(this, node:getStatement(), usingAdapterExpress.Body);
            PopFunction(this);

            usingInvocationExpression:AddArgument(usingAdapterExpress);
            usingInvocationExpression.ArgumentList.Arguments:AddRange(Linq.Select(variableExpressions, function (i) return CSharpLua.LuaAst.LuaArgumentSyntax(i); end, CSharpLua.LuaAst.LuaArgumentSyntax));
            return BuildCheckReturnInvocationExpression(this, usingInvocationExpression, node);
        end;
        VisitThisExpression = function (this, node) 
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax.This;
        end;
        IsBaseEnable = function (this, parent, symbol, overriddenFunc, T) 
            if IsOverridable(symbol) then
                local curTypeSymbol = GetTypeDeclarationSymbol(this, parent);
                if curTypeSymbol:getIsSealed() then
                    local exists = Linq.Any(curTypeSymbol:GetMembers():OfType(T), function (i) 
                        local overriddenSymbol = overriddenFunc(this, i);
                        return overriddenSymbol ~= nil and overriddenSymbol:Equals(symbol);
                    end);
                    if not exists then
                        return false;
                    end
                end
                return true;
            end
            return false;
        end;
        VisitBaseExpression = function (this, node) 
            local parent = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax, node:getParent());
            local symbol = GetSymbolInfo(this.semanticModel_, parent):getSymbol();

            local hasBase = false;
            repeat
                local default = symbol:getKind();
                if default == 9 --[[SymbolKind.Method]] then
                    
                        local methodSymbol = System.cast(Microsoft.CodeAnalysis.IMethodSymbol, symbol);
                        if IsBaseEnable(this, parent, methodSymbol, function (i) return i:getOverriddenMethod(); end, Microsoft.CodeAnalysis.IMethodSymbol) then
                            hasBase = true;
                        end
                        break;
                    elseif default == 15 --[[SymbolKind.Property]] then
                    
                        local propertySymbol = System.cast(Microsoft.CodeAnalysis.IPropertySymbol, symbol);
                        if not IsPropertyField(this, propertySymbol) then
                            if IsBaseEnable(this, parent, propertySymbol, function (i) return i:getOverriddenProperty(); end, Microsoft.CodeAnalysis.IPropertySymbol) then
                                hasBase = true;
                            end
                        end
                        break;
                    elseif default == 5 --[[SymbolKind.Event]] then
                    
                        local eventSymbol = System.cast(Microsoft.CodeAnalysis.IEventSymbol, symbol);
                        if not IsEventFiled(eventSymbol) then
                            if IsBaseEnable(this, parent, eventSymbol, function (i) return i:getOverriddenEvent(); end, Microsoft.CodeAnalysis.IEventSymbol) then
                                hasBase = true;
                            end
                        end
                        break;
                    end
            until 1;

            if hasBase then
                return getXmlMetaProvider(this):GetTypeName(symbol:getContainingType());
            else
                return CSharpLua.LuaAst.LuaIdentifierNameSyntax.This;
            end
        end;
        VisitConditionalAccessExpression = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local whenNotNull = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getWhenNotNull():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Access, expression, whenNotNull);
        end;
        VisitMemberBindingExpression = function (this, node) 
            local functionExpression = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, functionExpression);
            local temp = GetTempIdentifier(this, node:getName());
            local nameExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            functionExpression:AddParameter(temp);
            functionExpression.Body.Statements:Add(CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, nameExpression));
            PopFunction(this);
            return CSharpLua.LuaAst.LuaSimpleLambdaAdapterExpression(functionExpression);
        end;
        VisitDefaultExpression = function (this, node) 
            return BuildDefaultValueExpression(this, node:getType());
        end;
        VisitElementAccessExpression = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local argumentList = System.cast(CSharpLua.LuaAst.LuaArgumentListSyntax, node:getArgumentList():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local identifierName = CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, System.String.Empty);
            local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, identifierName, true);
            local propertyAdapter = CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax:new(2, memberAccess, identifierName);
            propertyAdapter.InvocationExpression.ArgumentList.Arguments:AddRange(argumentList.Arguments);
            return propertyAdapter;
        end;
        VisitInterpolatedStringExpression = function (this, node) 
            local index = 0;
            local sb = System.Text.StringBuilder();
            local expressions = System.List(CSharpLua.LuaAst.LuaExpressionSyntax)();
            for _, content in System.each(node:getContents()) do
                if IsKind(content, 8919 --[[SyntaxKind.InterpolatedStringText]]) then
                    local stringText = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax, content);
                    sb:Append(stringText:getTextToken():getValueText());
                else
                    local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, content:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    expressions:Add(expression);
                    sb:Append(123 --[['{']]);
                    sb:Append(index);
                    sb:Append(125 --[['}']]);
                    index = index + 1;
                end
            end

            local format;
            if Linq.Contains(node:getStringStartToken():getValueText(), 64 --[['@']]) then
                format = BuildVerbatimStringExpression(this, sb:ToString());
            else
                format = BuildStringLiteralExpression(this, sb:ToString());
            end
            local memberAccessExpression = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaParenthesizedExpressionSyntax(format), CSharpLua.LuaAst.LuaIdentifierNameSyntax.Format, true);
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(5, memberAccessExpression, expressions);
        end;
        VisitInterpolation = function (this, node) 
            return node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
        end;
        VisitInterpolatedStringText = function (this, node) 
            System.throw(System.InvalidOperationException());
        end;
        return {
            VisitObjectCreationExpression = VisitObjectCreationExpression, 
            VisitInitializerExpression = VisitInitializerExpression, 
            VisitBracketedArgumentList = VisitBracketedArgumentList, 
            VisitImplicitElementAccess = VisitImplicitElementAccess, 
            VisitGenericName = VisitGenericName, 
            VisitOmittedArraySizeExpression = VisitOmittedArraySizeExpression, 
            VisitArrayRankSpecifier = VisitArrayRankSpecifier, 
            VisitArrayType = VisitArrayType, 
            VisitArrayCreationExpression = VisitArrayCreationExpression, 
            VisitConstructorDeclaration = VisitConstructorDeclaration, 
            VisitSimpleBaseType = VisitSimpleBaseType, 
            VisitSimpleLambdaExpression = VisitSimpleLambdaExpression, 
            VisitParenthesizedLambdaExpression = VisitParenthesizedLambdaExpression, 
            VisitTypeParameter = VisitTypeParameter, 
            VisitTypeOfExpression = VisitTypeOfExpression, 
            VisitThrowStatement = VisitThrowStatement, 
            VisitCatchFilterClause = VisitCatchFilterClause, 
            VisitCatchClause = VisitCatchClause, 
            VisitCatchDeclaration = VisitCatchDeclaration, 
            VisitFinallyClause = VisitFinallyClause, 
            VisitTryStatement = VisitTryStatement, 
            VisitUsingStatement = VisitUsingStatement, 
            VisitThisExpression = VisitThisExpression, 
            VisitBaseExpression = VisitBaseExpression, 
            VisitConditionalAccessExpression = VisitConditionalAccessExpression, 
            VisitMemberBindingExpression = VisitMemberBindingExpression, 
            VisitDefaultExpression = VisitDefaultExpression, 
            VisitElementAccessExpression = VisitElementAccessExpression, 
            VisitInterpolatedStringExpression = VisitInterpolatedStringExpression, 
            VisitInterpolation = VisitInterpolation, 
            VisitInterpolatedStringText = VisitInterpolatedStringText
        };
    end);
end);
