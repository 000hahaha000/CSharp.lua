-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua", function (namespace) 
    namespace.class("CmdArgumentException", function (namespace) 
        local __ctor__;
        __ctor__ = function (this, message) 
            System.Exception.__ctor__(this, message);
        end;
        return {
            __inherits__ = {
                System.Exception
            }, 
            __ctor__ = __ctor__
        };
    end);
    namespace.class("CompilationErrorException", function (namespace) 
        local __ctor__;
        __ctor__ = function (this, message) 
            System.Exception.__ctor__(this, message);
        end;
        return {
            __inherits__ = {
                System.Exception
            }, 
            __ctor__ = __ctor__
        };
    end);
    namespace.class("Utility", function (namespace) 
        local GetCommondLines, First, Last, GetOrDefault, GetOrDefault, GetArgument, GetCurrentDirectory, Split, 
        IsPrivate, IsStatic, IsReadOnly, IsConst, IsParams, IsStringType, IsDelegateType, IsIntegerType, 
        IsImmutable, IsInterfaceImplementation, InterfaceImplementations, IsFromCode, IsOverridable, IsPropertyField, IsEventFiled, IsAssignment, 
        systemLinqEnumerableType_, IsSystemLinqEnumerable, GetLocationString;
        GetCommondLines = function (args) 
            local cmds = System.Dictionary(System.String, System.Array(System.String))();

            local key = "";
            local values = System.List(System.String)();

            for _, arg in System.each(args) do
                local i = arg:Trim();
                if i:StartsWith("-") then
                    if not System.String.IsNullOrEmpty(key) then
                        cmds:Add(key, values:ToArray());
                        key = "";
                        values:Clear();
                    end
                    key = i;
                else
                    values:Add(i);
                end
            end

            if not System.String.IsNullOrEmpty(key) then
                cmds:Add(key, values:ToArray());
            end
            return cmds;
        end;
        First = function (list, T) 
            return list:get(0);
        end;
        Last = function (list, T) 
            return list:get(list:getCount() - 1);
        end;
        GetOrDefault = function (list, index, v, T) 
            v = v or System.default(T);
            local default;
            if index >= 0 and index < list:getCount() then
                default = list:get(index);
            else
                default = v;
            end
            return default;
        end;
        GetOrDefault = function (dict, key, t, K, T) 
            t = t or System.default(T);
            local v;
            local default;
            default, v = dict:TryGetValue(key, v);
            if default then
                return v;
            end
            return t;
        end;
        GetArgument = function (args, name, isOption) 
            isOption = isOption or false;
            local values = GetOrDefault(args, name, nil, System.String, System.Array(System.String));
            if values == nil or #values == 0 then
                if isOption then
                    return nil;
                end
                System.throw(CSharpLua.CmdArgumentException((name or "") .. " is not found"));
            end
            return values:get(0);
        end;
        GetCurrentDirectory = function (path) 
            local CurrentDirectorySign1 = "~/";
            local CurrentDirectorySign2 = "~\\";

            if path:StartsWith(CurrentDirectorySign1) then
                return System.IO.Path.Combine(System.AppDomain.getCurrentDomain():getBaseDirectory(), path:Substring(#CurrentDirectorySign1));
            elseif path:StartsWith(CurrentDirectorySign2) then
                return System.IO.Path.Combine(System.AppDomain.getCurrentDomain():getBaseDirectory(), path:Substring(#CurrentDirectorySign2));
            end

            return System.IO.Path.Combine(System.Environment.getCurrentDirectory(), path);
        end;
        Split = function (s, isPath) 
            isPath = isPath or true;
            local list = System.HashSet(System.String)();
            if not System.String.IsNullOrEmpty(s) then
                local array = s:Split(59 --[[';']]);
                for _, i in System.each(array) do
                    local default;
                    if isPath then
                        default = GetCurrentDirectory(this, i);
                    else
                        default = i;
                    end
                    list:Add(default);
                end
            end
            return Linq.ToArray(list);
        end;
        IsPrivate = function (modifiers) 
            return Linq.Any(modifiers, function (i) return IsKind(i, 8344 --[[SyntaxKind.PrivateKeyword]]); end);
        end;
        IsStatic = function (modifiers) 
            return Linq.Any(modifiers, function (i) return IsKind(i, 8347 --[[SyntaxKind.StaticKeyword]]); end);
        end;
        IsReadOnly = function (modifiers) 
            return Linq.Any(modifiers, function (i) return IsKind(i, 8348 --[[SyntaxKind.ReadOnlyKeyword]]); end);
        end;
        IsConst = function (modifiers) 
            return Linq.Any(modifiers, function (i) return IsKind(i, 8350 --[[SyntaxKind.ConstKeyword]]); end);
        end;
        IsParams = function (modifiers) 
            return Linq.Any(modifiers, function (i) return IsKind(i, 8365 --[[SyntaxKind.ParamsKeyword]]); end);
        end;
        IsStringType = function (type) 
            return type:getSpecialType() == 20 --[[SpecialType.System_String]];
        end;
        IsDelegateType = function (type) 
            return type:getTypeKind() == 3 --[[TypeKind.Delegate]];
        end;
        IsIntegerType = function (type) 
            return type:getSpecialType() >= 9 --[[SpecialType.System_SByte]] and type:getSpecialType() <= 16 --[[SpecialType.System_UInt64]];
        end;
        IsImmutable = function (type) 
            local isImmutable = (type:getIsValueType() and type:getIsDefinition()) or IsStringType(type) or IsDelegateType(type);
            return isImmutable;
        end;
        IsInterfaceImplementation = function (symbol, T) 
            if not symbol:getIsStatic() then
                local type = symbol:getContainingType();
                if type ~= nil then
                    local interfaceSymbols = Linq.SelectMany(type:getAllInterfaces(), function (i) return i:GetMembers():OfType(T); end, T);
                    return Linq.Any(interfaceSymbols, function (i) return symbol:Equals(type:FindImplementationForInterfaceMember(i)); end);
                end
            end
            return false;
        end;
        InterfaceImplementations = function (symbol, T) 
            if not symbol:getIsStatic() then
                local type = symbol:getContainingType();
                if type ~= nil then
                    local interfaceSymbols = Linq.SelectMany(type:getAllInterfaces(), function (i) return i:GetMembers():OfType(T); end, T);
                    return Linq.Where(interfaceSymbols, function (i) return symbol:Equals(type:FindImplementationForInterfaceMember(i)); end);
                end
            end
            return nil;
        end;
        IsFromCode = function (symbol) 
            return symbol:getDeclaringSyntaxReferences():getLength() > 0;
        end;
        IsOverridable = function (symbol) 
            return not symbol:getIsStatic() and (symbol:getIsAbstract() or symbol:getIsVirtual() or symbol:getIsOverride());
        end;
        IsPropertyField = function (symbol) 
            if IsOverridable(symbol) then
                return false;
            end

            local syntaxReference = FirstOrDefault(symbol:getDeclaringSyntaxReferences(), Microsoft.CodeAnalysis.SyntaxReference);
            if syntaxReference ~= nil then
                local node = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax, syntaxReference:GetSyntax());
                local hasGet = false;
                local hasSet = false;
                if node:getAccessorList() ~= nil then
                    for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                        if accessor:getBody() ~= nil then
                            if IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]]) then
                                assert(not hasGet);
                                hasGet = true;
                            else
                                assert(not hasSet);
                                hasSet = true;
                            end
                        end
                    end
                else
                    assert(not hasGet);
                    hasGet = true;
                end
                local isAuto = not hasGet and not hasSet;
                if isAuto then
                    if IsInterfaceImplementation(symbol, Microsoft.CodeAnalysis.IPropertySymbol) then
                        isAuto = false;
                    end
                end
                return isAuto;
            end
            return false;
        end;
        IsEventFiled = function (symbol) 
            if IsOverridable(symbol) then
                return false;
            end

            local syntaxReference = FirstOrDefault(symbol:getDeclaringSyntaxReferences(), Microsoft.CodeAnalysis.SyntaxReference);
            if syntaxReference ~= nil then
                local isField = IsKind(syntaxReference:GetSyntax(), 8795 --[[SyntaxKind.VariableDeclarator]]);
                if isField then
                    if IsInterfaceImplementation(symbol, Microsoft.CodeAnalysis.IEventSymbol) then
                        isField = false;
                    end
                end
                return isField;
            end
            return false;
        end;
        IsAssignment = function (kind) 
            return kind >= 8714 --[[SyntaxKind.SimpleAssignmentExpression]] and kind <= 8724 --[[SyntaxKind.RightShiftAssignmentExpression]];
        end;
        IsSystemLinqEnumerable = function (symbol) 
            if systemLinqEnumerableType_ ~= nil then
                return symbol == systemLinqEnumerableType_;
            else
                local success = symbol:ToString() == CSharpLua.LuaAst.LuaIdentifierNameSyntax.SystemLinqEnumerable.ValueText;
                if success then
                    systemLinqEnumerableType_ = symbol;
                end
                return success;
            end
        end;
        GetLocationString = function (node) 
            local location = node:getSyntaxTree():GetLocation(node:getSpan());
            local methodInfo = location:GetType():GetMethod("GetDebuggerDisplay", 4 --[[BindingFlags.Instance]] | 32 --[[BindingFlags.NonPublic]]);
            return System.cast(System.String, methodInfo:Invoke(location, nil));
        end;
        return {
            GetCommondLines = GetCommondLines, 
            First = First, 
            Last = Last, 
            GetOrDefault = GetOrDefault, 
            GetOrDefault = GetOrDefault, 
            GetArgument = GetArgument, 
            GetCurrentDirectory = GetCurrentDirectory, 
            Split = Split, 
            IsPrivate = IsPrivate, 
            IsStatic = IsStatic, 
            IsReadOnly = IsReadOnly, 
            IsConst = IsConst, 
            IsParams = IsParams, 
            IsStringType = IsStringType, 
            IsDelegateType = IsDelegateType, 
            IsIntegerType = IsIntegerType, 
            IsImmutable = IsImmutable, 
            IsInterfaceImplementation = IsInterfaceImplementation, 
            InterfaceImplementations = InterfaceImplementations, 
            IsFromCode = IsFromCode, 
            IsOverridable = IsOverridable, 
            IsPropertyField = IsPropertyField, 
            IsEventFiled = IsEventFiled, 
            IsAssignment = IsAssignment, 
            IsSystemLinqEnumerable = IsSystemLinqEnumerable, 
            GetLocationString = GetLocationString
        };
    end);
end);
