-- Generated by CSharp.lua Compiler 1.0.0.0
local System = System;
local Linq = System.Linq.Enumerable;
System.namespace("CSharpLua", function (namespace) 
    namespace.class("LuaSyntaxNodeTransfor", function (namespace) 
        namespace.class("BlockCommonNode", function (namespace) 
            local CompareTo, Contains, Visit, __ctor1__, __ctor2__;
            __ctor1__ = function (this, comment) 
                this.Comment = comment;
                this.LineSpan = comment:getSyntaxTree():GetLineSpan(comment:getSpan());
            end;
            __ctor2__ = function (this, statement) 
                this.Statement = statement;
                this.LineSpan = statement:getSyntaxTree():GetLineSpan(statement:getSpan());
            end;
            CompareTo = function (this, other) 
                return this.LineSpan:getStartLinePosition():CompareTo(other.LineSpan:getStartLinePosition());
            end;
            Contains = function (this, other) 
                local otherLineSpan = other.LineSpan;
                return otherLineSpan:getStartLinePosition() > this.LineSpan:getStartLinePosition() and otherLineSpan:getEndLinePosition() < this.LineSpan:getEndLinePosition();
            end;
            Visit = function (this, transfor, block, lastLine) 
                if lastLine ~= - 1 then
                    local count = this.LineSpan:getStartLinePosition():getLine() - lastLine - 1;
                    if count > 0 then
                        block.Statements:Add(CSharpLua.LuaAst.LuaBlankLinesStatement:new(1, count));
                    end
                end

                if this.Statement ~= nil then
                    local statementNode = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, this.Statement:Accept(transfor, CSharpLua.LuaAst.LuaSyntaxNode));
                    block.Statements:Add(statementNode);
                else
                    local content = this.Comment:ToString();
                    if IsKind(this.Comment, 8541 --[[SyntaxKind.SingleLineCommentTrivia]]) then
                        local commentContent = content:Substring(2 --[[BlockCommonNode.kCommentCharCount]]);
                        local singleComment = CSharpLua.LuaAst.LuaShortCommentStatement(commentContent);
                        block.Statements:Add(singleComment);
                    else
                        local commentContent = content:Substring(2 --[[BlockCommonNode.kCommentCharCount]], #content - 2 --[[BlockCommonNode.kCommentCharCount]] - 2 --[[BlockCommonNode.kCommentCharCount]]);
                        local longComment = CSharpLua.LuaAst.LuaLongCommentStatement(commentContent);
                        block.Statements:Add(longComment);
                    end
                end

                lastLine = this.LineSpan:getEndLinePosition():getLine();
            end;
            return {
                __inherits__ = {
                    System.IComparable_1(CSharpLua.LuaSyntaxNodeTransfor.BlockCommonNode)
                }, 
                Comment = System.default(Microsoft.CodeAnalysis.SyntaxTrivia), 
                LineSpan = System.default(Microsoft.CodeAnalysis.FileLinePositionSpan), 
                CompareTo = CompareTo, 
                Contains = Contains, 
                Visit = Visit, 
                __ctor__ = {
                    __ctor1__, 
                    __ctor2__
                }
            };
        end);
        local operatorTokenMapps_, getXmlMetaProvider, GetOperatorToken, getIsLuaNewest, getCurCompilationUnit, getCurType, getCurFunction, PushFunction, 
        PopFunction, getCurBlock, VisitCompilationUnit, VisitNamespaceDeclaration, VisitTypeDeclaration, VisitClassDeclaration, VisitStructDeclaration, VisitInterfaceDeclaration, 
        VisitEnumDeclaration, VisitYield, BuildMethodDefaultParameterInit, VisitMethodDeclaration, GetPredefinedTypeDefaultValue, GetTempIdentifier, BuildDefaultValueExpression, VisitBaseFieldDeclarationSyntax, 
        VisitFieldDeclaration, GetFieldValueExpression, AddField, VisitPropertyDeclaration, VisitEventDeclaration, VisitEventFieldDeclaration, VisitEnumMemberDeclaration, VisitIndexerDeclaration, 
        VisitParameterList, VisitParameter, VisitBlock, VisitReturnStatement, VisitExpressionStatement, BuildCommonAssignmentExpression, BuildDelegateAssignmentExpression, BuildLuaAssignmentExpression, 
        VisitAssignmentExpression, BuildInvokeRefOrOut, CheckCodeTemplateInvocationExpression, VisitInvocationExpression, BuildMemberAccessTargetExpression, CheckMemberAccessCodeTemplate, VisitMemberAccessExpression, BuildStaticFieldName, 
        IsInternalNode, VisitFieldOrEventIdentifierName, GetMethodNameExpression, VisitIdentifierName, VisitQualifiedName, BuildArgumentList, VisitArgumentList, VisitArgument, 
        VisitLiteralExpression, VisitLocalDeclarationStatement, VisitVariableDeclaration, VisitVariableDeclarator, VisitEqualsValueClause, VisitPredefinedType, WriteStatementOrBlock, VisitIfStatement, 
        VisitElseClause, VisitSwitchStatement, VisitSwitchSection, VisitCaseSwitchLabel, VisitBreakStatement, WrapStringConcatExpression, BuildStringConcatExpression, BuildStringConcatExpression, 
        BuildBinaryInvokeExpression, BuildIntegerDivExpression, BuildBinaryExpression, BuildBitExpression, VisitBinaryExpression, GetLuaAssignmentExpressionSyntax, VisitPrefixUnaryExpression, VisitPostfixUnaryExpression, 
        VisitContinueStatement, VisitLoopBody, VisitForEachStatement, VisitWhileStatement, VisitForStatement, VisitDoStatement, VisitYieldStatement, VisitParenthesizedExpression, 
        MayBeNullOrFalse, VisitConditionalExpression, VisitGotoStatement, VisitLabeledStatement, VisitEmptyStatement, VisitCastExpression, __staticCtor__, __init__, 
        __ctor__;
        __staticCtor__ = function (this) 
            operatorTokenMapps_ = System.create(System.Dictionary(System.String, System.String)(), function (default) 
                default:set("!=", "~=" --[[Tokens.NotEquals]]);
                default:set("!", "not" --[[Keyword.Not]]);
                default:set("&&", "and" --[[Keyword.And]]);
                default:set("||", "or" --[[Keyword.Or]]);
                default:set("??", "or" --[[Keyword.Or]]);
                default:set("^", "~");
            end);
        end;
        __init__ = function (this) 
            this.compilationUnits_ = System.Stack(CSharpLua.LuaAst.LuaCompilationUnitSyntax)();
            this.typeDeclarations_ = System.Stack(CSharpLua.LuaAst.LuaTypeDeclarationSyntax)();
            this.functions_ = System.Stack(CSharpLua.LuaAst.LuaFunctionExpressionSyntax)();
            this.switchs_ = System.Stack(CSharpLua.LuaAst.LuaSwitchAdapterStatementSyntax)();
            this.blocks_ = System.Stack(CSharpLua.LuaAst.LuaBlockSyntax)();
        end;
        __ctor__ = function (this, generator, semanticModel) 
            __init__(this);
            this.generator_ = generator;
            this.semanticModel_ = semanticModel;
        end;
        getXmlMetaProvider = function (this) 
            return this.generator_.XmlMetaProvider;
        end;
        GetOperatorToken = function (operatorToken) 
            local token = operatorToken:getValueText();
            return GetOrDefault(operatorTokenMapps_, token, token, System.String, System.String);
        end;
        getIsLuaNewest = function (this) 
            return this.generator_.Setting.IsNewest;
        end;
        getCurCompilationUnit = function (this) 
            return this.compilationUnits_:Peek();
        end;
        getCurType = function (this) 
            return this.typeDeclarations_:Peek();
        end;
        getCurFunction = function (this) 
            return this.functions_:Peek();
        end;
        PushFunction = function (this, function_) 
            this.functions_:Push(function_);
            this.localMappingCounter_ = this.localMappingCounter_ + 1;
        end;
        PopFunction = function (this) 
            this.functions_:Pop();
            this.localMappingCounter_ = this.localMappingCounter_ - 1;
            if this.localMappingCounter_ == 0 then
                this.localReservedNames_:Clear();
            end
        end;
        getCurBlock = function (this) 
            return this.blocks_:Peek();
        end;
        VisitCompilationUnit = function (this, node) 
            local compilationUnit = System.create(CSharpLua.LuaAst.LuaCompilationUnitSyntax(), function (default) 
                default.FilePath = node:getSyntaxTree():getFilePath();
            end);
            this.compilationUnits_:Push(compilationUnit);
            for _, member in System.each(node:getMembers()) do
                local memberNode = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, member:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local typeDeclaration = System.as(memberNode, CSharpLua.LuaAst.LuaTypeDeclarationSyntax);
                if typeDeclaration ~= nil then
                    compilationUnit:AddTypeDeclaration(typeDeclaration);
                else
                    compilationUnit.Statements:Add(memberNode);
                end
            end
            this.compilationUnits_:Pop();
            return compilationUnit;
        end;
        VisitNamespaceDeclaration = function (this, node) 
            local name = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local namespaceDeclaration = CSharpLua.LuaAst.LuaNamespaceDeclarationSyntax(name);
            for _, member in System.each(node:getMembers()) do
                local memberNode = System.cast(CSharpLua.LuaAst.LuaTypeDeclarationSyntax, member:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                namespaceDeclaration:Add(memberNode);
            end
            return namespaceDeclaration;
        end;
        VisitTypeDeclaration = function (this, node, typeDeclaration) 
            this.typeDeclarations_:Push(typeDeclaration);
            if node:getTypeParameterList() ~= nil then
                for _, typeParameter in System.each(node:getTypeParameterList():getParameters()) do
                    local typeIdentifier = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, typeParameter:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    typeDeclaration:AddTypeIdentifier(typeIdentifier);
                end
            end
            if node:getBaseList() ~= nil then
                local baseTypes = System.List(CSharpLua.LuaAst.LuaExpressionSyntax)();
                for _, baseType in System.each(node:getBaseList():getTypes()) do
                    local baseTypeName = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, baseType:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    baseTypes:Add(baseTypeName);
                end
                typeDeclaration:AddBaseTypes(baseTypes);
            end
            for _, member in System.each(node:getMembers()) do
                local newMember = member:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
                local kind = member:Kind();
                if kind >= 8855 --[[SyntaxKind.ClassDeclaration]] and kind <= 8858 --[[SyntaxKind.EnumDeclaration]] then
                    typeDeclaration:Add(System.cast(CSharpLua.LuaAst.LuaStatementSyntax, newMember));
                end
            end
            this.typeDeclarations_:Pop();
        end;
        VisitClassDeclaration = function (this, node) 
            local name = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local classDeclaration = CSharpLua.LuaAst.LuaClassDeclarationSyntax(name);
            VisitTypeDeclaration(this, node, classDeclaration);
            return classDeclaration;
        end;
        VisitStructDeclaration = function (this, node) 
            local name = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local structDeclaration = CSharpLua.LuaAst.LuaStructDeclarationSyntax(name);
            VisitTypeDeclaration(this, node, structDeclaration);
            return structDeclaration;
        end;
        VisitInterfaceDeclaration = function (this, node) 
            local name = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local interfaceDeclaration = CSharpLua.LuaAst.LuaInterfaceDeclarationSyntax(name);
            VisitTypeDeclaration(this, node, interfaceDeclaration);
            return interfaceDeclaration;
        end;
        VisitEnumDeclaration = function (this, node) 
            local symbol = GetDeclaredSymbol(this.semanticModel_, node);
            local fullName = symbol:ToString();
            local name = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local enumDeclaration = CSharpLua.LuaAst.LuaEnumDeclarationSyntax(fullName, name);
            this.typeDeclarations_:Push(enumDeclaration);
            for _, member in System.each(node:getMembers()) do
                local statement = System.cast(CSharpLua.LuaAst.LuaKeyValueTableItemSyntax, member:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                enumDeclaration:Add(statement);
            end
            this.typeDeclarations_:Pop();
            return enumDeclaration;
        end;
        VisitYield = function (this, node, function_) 
            assert(function_.HasYield);

            local nameSyntax = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax, node:getReturnType());
            local name = "yield" --[[Tokens.Yield]] .. (nameSyntax:getIdentifier():getValueText() or "");
            local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.System, CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name));
            local invokeExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
            local wrapFunction = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();

            local parameters = function_.ParameterList.Parameters;
            wrapFunction.ParameterList.Parameters:AddRange(parameters);
            wrapFunction.Body.Statements:AddRange(function_.Body.Statements);
            invokeExpression:AddArgument(wrapFunction);
            if IsKind(node:getReturnType(), 8618 --[[SyntaxKind.GenericName]]) then
                local genericNameSyntax = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax, nameSyntax);
                local typeName = genericNameSyntax:getTypeArgumentList():getArguments():First();
                local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, typeName:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                invokeExpression:AddArgument(expression);
            else
                invokeExpression:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.Object);
            end
            invokeExpression.ArgumentList.Arguments:AddRange(Linq.Select(parameters, function (i) return CSharpLua.LuaAst.LuaArgumentSyntax(i.Identifier); end, CSharpLua.LuaAst.LuaArgumentSyntax));

            local returnStatement = CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, invokeExpression);
            function_.Body.Statements:Clear();
            function_.Body.Statements:Add(returnStatement);
        end;
        BuildMethodDefaultParameterInit = function (this, parameterIdentifier, defaultValue) 
            local binaryExpression = CSharpLua.LuaAst.LuaBinaryExpressionSyntax(parameterIdentifier, "or" --[[Keyword.Or]], defaultValue);
            local initAssignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(parameterIdentifier, binaryExpression);
            return CSharpLua.LuaAst.LuaExpressionStatementSyntax(initAssignment);
        end;
        VisitMethodDeclaration = function (this, node) 
            local symbol = GetDeclaredSymbol(this.semanticModel_, node);
            local methodName = getXmlMetaProvider(this):GetMethodMapName(symbol);
            local name = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, methodName);
            local function_ = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
            PushFunction(this, function_);
            if not IsStatic(node:getModifiers()) then
                function_:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
            end

            for _, parameter in System.each(node:getParameterList():getParameters()) do
                local luaParameter = System.cast(CSharpLua.LuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                luaParameter = CheckParameterName(this, luaParameter, parameter);
                function_.ParameterList.Parameters:Add(luaParameter);
                if parameter:getDefault() ~= nil then
                    local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, parameter:getDefault():getValue():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    local intiStatement = BuildMethodDefaultParameterInit(this, luaParameter.Identifier, expression);
                    function_.Body.Statements:Add(intiStatement);
                else
                    if IsParams(parameter:getModifiers()) then
                        local typeName = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, (System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax, parameter:getType())):getElementType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        local emptyArray = BuildEmptyArray(this, typeName);
                        local intiStatement = BuildMethodDefaultParameterInit(this, luaParameter.Identifier, emptyArray);
                        function_.Body.Statements:Add(intiStatement);
                    end
                end
            end
            if node:getTypeParameterList() ~= nil then
                for _, typeParameter in System.each(node:getTypeParameterList():getParameters()) do
                    local typeName = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, typeParameter:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    function_:AddParameter(typeName);
                end
            end

            local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, node:getBody():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            function_.Body.Statements:AddRange(block.Statements);
            if function_.HasYield then
                VisitYield(this, node, function_);
            end
            PopFunction(this);
            getCurType(this):AddMethod(name, function_, IsPrivate(node:getModifiers()));
            return function_;
        end;
        GetPredefinedTypeDefaultValue = function (typeSymbol) 
            repeat
                local default = typeSymbol:getSpecialType();
                if default == 7 --[[SpecialType.System_Boolean]] then
                    
                        return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, System.default(System.Boolean):ToString());
                    elseif default == 8 --[[SpecialType.System_Char]] then
                    
                        return CSharpLua.LuaAst.LuaCharacterLiteralExpression(System.default(System.Char));
                    elseif default == 9 --[[SpecialType.System_SByte]] or default == 10 --[[SpecialType.System_Byte]] or default == 11 --[[SpecialType.System_Int16]] or default == 12 --[[SpecialType.System_UInt16]] or default == 13 --[[SpecialType.System_Int32]] or default == 14 --[[SpecialType.System_UInt32]] or default == 15 --[[SpecialType.System_Int64]] or default == 16 --[[SpecialType.System_UInt64]] then
                    
                        return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(2, 0);
                    elseif default == 18 --[[SpecialType.System_Single]] or default == 19 --[[SpecialType.System_Double]] then
                    
                        return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, (0):ToString());
                    else
                    return nil;
                end
            until 1;
        end;
        GetTempIdentifier = function (this, node) 
            local default = getCurFunction(this).TempIndex;
            getCurFunction(this).TempIndex = getCurFunction(this).TempIndex + 1;
            local index = default;
            local name = GetOrDefault(CSharpLua.LuaAst.LuaSyntaxNode.TempIdentifiers, index, nil, System.String);
            if name == nil then
                System.throw(CSharpLua.CompilationErrorException((("{0} : Your code is startling, {1} "):Format(GetLocationString(node), #CSharpLua.LuaAst.LuaSyntaxNode.TempIdentifiers) or "") .. "temporary variables is not enough, please refactor your code."));
            end
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        BuildDefaultValueExpression = function (this, type) 
            local identifierName = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, type:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLua.LuaAst.LuaIdentifierNameSyntax.SystemDefault, identifierName);
        end;
        VisitBaseFieldDeclarationSyntax = function (this, node) 
            if not IsConst(node:getModifiers()) then
                local isStatic = IsStatic(node:getModifiers());
                local isPrivate = IsPrivate(node:getModifiers());
                local isReadOnly = IsReadOnly(node:getModifiers());
                local type = node:getDeclaration():getType();
                local typeSymbol = System.cast(Microsoft.CodeAnalysis.ITypeSymbol, GetSymbolInfo(this.semanticModel_, type):getSymbol());
                local isImmutable = IsImmutable(typeSymbol);
                for _, variable in System.each(node:getDeclaration():getVariables()) do
                    local continue;
                    repeat
                        if IsKind(node, 8874 --[[SyntaxKind.EventFieldDeclaration]]) then
                            local eventSymbol = System.cast(Microsoft.CodeAnalysis.IEventSymbol, GetDeclaredSymbol(this.semanticModel_, variable));
                            if IsOverridable(eventSymbol) or IsInterfaceImplementation(eventSymbol, Microsoft.CodeAnalysis.IEventSymbol) then
                                local valueIsLiteral;
                                local default;
                                default, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, System.access(variable:getInitializer(), function (default) return this:getValue(); end), valueIsLiteral);
                                local valueExpression = default;
                                getCurType(this):AddEvent(variable:getIdentifier():getValueText(), valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate);
                                continue = true;
                                break;
                            end
                        end
                        AddField(this, type, typeSymbol, variable:getIdentifier(), System.access(variable:getInitializer(), function (default) return this:getValue(); end), isImmutable, isStatic, isPrivate, isReadOnly);
                        continue = true;
                    until 1;
                    if not continue then
                        break;
                    end
                end
            else
                local isPrivate = IsPrivate(node:getModifiers());
                local type = node:getDeclaration():getType();
                local typeSymbol = System.cast(Microsoft.CodeAnalysis.ITypeSymbol, GetSymbolInfo(this.semanticModel_, type):getSymbol());
                if typeSymbol:getSpecialType() == 20 --[[SpecialType.System_String]] then
                    for _, variable in System.each(node:getDeclaration():getVariables()) do
                        local value = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax, variable:getInitializer():getValue());
                        if #value:getToken():getValueText() > 25 --[[LuaSyntaxNode.StringConstInlineCount]] then
                            AddField(this, type, typeSymbol, variable:getIdentifier(), value, true, true, isPrivate, true);
                        end
                    end
                end
            end
        end;
        VisitFieldDeclaration = function (this, node) 
            VisitBaseFieldDeclarationSyntax(this, node);
            return Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(TResult).VisitFieldDeclaration(this, node);
        end;
        GetFieldValueExpression = function (this, type, typeSymbol, expression, valueIsLiteral) 
            local valueExpression = nil;
            valueIsLiteral = false;
            if expression ~= nil then
                valueExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                valueIsLiteral = System.is(expression, Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax);
            end
            if valueExpression == nil then
                if typeSymbol:getIsValueType() then
                    if typeSymbol:getIsDefinition() then
                        local defalutValue = GetPredefinedTypeDefaultValue(this, typeSymbol);
                        if defalutValue ~= nil then
                            valueExpression = defalutValue;
                        else
                            valueExpression = BuildDefaultValueExpression(this, type);
                        end
                        valueIsLiteral = true;
                    else
                        valueExpression = BuildDefaultValueExpression(this, type);
                    end
                end
            end
            return valueExpression;
        end;
        AddField = function (this, type, typeSymbol, identifier, expression, isImmutable, isStatic, isPrivate, isReadOnly) 
            local name = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, identifier:getValueText());
            local valueIsLiteral;
            local default;
            default, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, expression, valueIsLiteral);
            local valueExpression = default;
            getCurType(this):AddField(name, valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate, isReadOnly);
        end;
        VisitPropertyDeclaration = function (this, node) 
            local isStatic = IsStatic(node:getModifiers());
            local isPrivate = IsPrivate(node:getModifiers());
            local hasGet = false;
            local hasSet = false;
            if node:getAccessorList() ~= nil then
                for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                    if accessor:getBody() ~= nil then
                        local functionExpression = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
                        if not isStatic then
                            functionExpression:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                        end
                        PushFunction(this, functionExpression);
                        local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        PopFunction(this);
                        functionExpression.Body.Statements:AddRange(block.Statements);
                        local name = CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, node:getIdentifier():getValueText());
                        getCurType(this):AddMethod(name, functionExpression, isPrivate);
                        if IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]]) then
                            assert(not hasGet);
                            hasGet = true;
                        else
                            assert(not hasSet);
                            functionExpression:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.Value);
                            name.IsGetOrAdd = false;
                            hasSet = true;
                        end
                    end
                end
            else
                assert(not hasGet);
                local name = CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, node:getIdentifier():getValueText());
                local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpressionBody():getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local functionExpress = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
                if not isStatic then
                    functionExpress:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                end
                local returnStatement = CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, expression);
                functionExpress.Body.Statements:Add(returnStatement);
                getCurType(this):AddMethod(name, functionExpress, isPrivate);
                hasGet = true;
            end

            if not hasGet and not hasSet then
                if not IsKind(node:getParent(), 8857 --[[SyntaxKind.InterfaceDeclaration]]) then
                    local type = node:getType();
                    local typeSymbol = System.cast(Microsoft.CodeAnalysis.ITypeSymbol, GetSymbolInfo(this.semanticModel_, type):getSymbol());
                    local isImmutable = IsImmutable(typeSymbol);
                    if isStatic then
                        local isReadOnly = node:getAccessorList():getAccessors():getCount() == 1 and node:getAccessorList():getAccessors():get(0):getBody() == nil;
                        AddField(this, type, typeSymbol, node:getIdentifier(), System.access(node:getInitializer(), function (default) return this:getValue(); end), isImmutable, isStatic, isPrivate, isReadOnly);
                    else
                        local isAuto = IsPropertyField(GetDeclaredSymbol(this.semanticModel_, node));
                        if isAuto then
                            local isReadOnly = node:getAccessorList():getAccessors():getCount() == 1 and node:getAccessorList():getAccessors():get(0):getBody() == nil;
                            AddField(this, type, typeSymbol, node:getIdentifier(), System.access(node:getInitializer(), function (default) return this:getValue(); end), isImmutable, isStatic, isPrivate, isReadOnly);
                        else
                            local valueIsLiteral;
                            local default;
                            default, valueIsLiteral = GetFieldValueExpression(this, type, typeSymbol, System.access(node:getInitializer(), function (default) return this:getValue(); end), valueIsLiteral);
                            local valueExpression = default;
                            getCurType(this):AddProperty(node:getIdentifier():getValueText(), valueExpression, isImmutable and valueIsLiteral, isStatic, isPrivate);
                        end
                    end
                end
            end

            return Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(TResult).VisitPropertyDeclaration(this, node);
        end;
        VisitEventDeclaration = function (this, node) 
            local isStatic = IsStatic(node:getModifiers());
            local isPrivate = IsPrivate(node:getModifiers());
            for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local functionExpress = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
                if not isStatic then
                    functionExpress:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                end
                functionExpress:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.Value);
                functionExpress.Body.Statements:AddRange(block.Statements);
                local name = CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(false, node:getIdentifier():getValueText());
                getCurType(this):AddMethod(name, functionExpress, isPrivate);
                if IsKind(accessor, 8899 --[[SyntaxKind.RemoveAccessorDeclaration]]) then
                    name.IsGetOrAdd = false;
                end
            end

            return Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(TResult).VisitEventDeclaration(this, node);
        end;
        VisitEventFieldDeclaration = function (this, node) 
            VisitBaseFieldDeclarationSyntax(this, node);
            return Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(TResult).VisitEventFieldDeclaration(this, node);
        end;
        VisitEnumMemberDeclaration = function (this, node) 
            local symbol = GetDeclaredSymbol(this.semanticModel_, node);
            assert(symbol:getHasConstantValue());
            local identifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local value = CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, symbol:getConstantValue():ToString());
            return CSharpLua.LuaAst.LuaKeyValueTableItemSyntax(CSharpLua.LuaAst.LuaTableLiteralKeySyntax(identifier), value);
        end;
        VisitIndexerDeclaration = function (this, node) 
            local isStatic = IsStatic(node:getModifiers());
            local isPrivate = IsPrivate(node:getModifiers());
            local hasGet = false;
            local hasSet = false;
            for _, accessor in System.each(node:getAccessorList():getAccessors()) do
                local functionExpression = CSharpLua.LuaAst.LuaFunctionExpressionSyntax();
                if not isStatic then
                    functionExpression:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                end
                PushFunction(this, functionExpression);
                local block = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, accessor:getBody():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                PopFunction(this);
                functionExpression.Body.Statements:AddRange(block.Statements);
                local name = CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(true, System.String.Empty);
                getCurType(this):AddMethod(name, functionExpression, isPrivate);
                if IsKind(accessor, 8896 --[[SyntaxKind.GetAccessorDeclaration]]) then
                    assert(not hasGet);
                    hasGet = true;
                else
                    assert(not hasSet);
                    functionExpression:AddParameter(CSharpLua.LuaAst.LuaIdentifierNameSyntax.Value);
                    name.IsGetOrAdd = false;
                    hasSet = true;
                end
            end

            return Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(TResult).VisitIndexerDeclaration(this, node);
        end;
        VisitParameterList = function (this, node) 
            local parameterList = CSharpLua.LuaAst.LuaParameterListSyntax();
            for _, parameter in System.each(node:getParameters()) do
                local newNode = System.cast(CSharpLua.LuaAst.LuaParameterSyntax, parameter:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                parameterList.Parameters:Add(newNode);
            end
            return parameterList;
        end;
        VisitParameter = function (this, node) 
            local identifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            return CSharpLua.LuaAst.LuaParameterSyntax(identifier);
        end;
        VisitBlock = function (this, node) 
            local block = CSharpLua.LuaAst.LuaBlockSyntax();
            this.blocks_:Push(block);

            local comments = Linq.Where(node:DescendantTrivia(), function (i) return IsKind(i, 8541 --[[SyntaxKind.SingleLineCommentTrivia]]) or IsKind(i, 8542 --[[SyntaxKind.MultiLineCommentTrivia]]); end);
            local commentNodes = Linq.Select(comments, function (i) return CSharpLua.LuaSyntaxNodeTransfor.BlockCommonNode:new(1, i); end, CSharpLua.BlockCommonNode);

            local nodes = Linq.ToList(Linq.Select(node:getStatements(), function (i) return CSharpLua.LuaSyntaxNodeTransfor.BlockCommonNode:new(2, i); end, CSharpLua.BlockCommonNode));
            local hasComments = false;
            for _, comment in System.each(commentNodes) do
                local isContains = Linq.Any(nodes, function (i) return i:Contains(comment); end);
                if not isContains then
                    nodes:Add(comment);
                    hasComments = true;
                end
            end
            if hasComments then
                nodes:Sort();
            end

            local lastLine = - 1;
            for _, common in System.each(nodes) do
                lastLine = common:Visit(this, block, lastLine);
            end

            this.blocks_:Pop();
            if IsKind(node:getParent(), 8792 --[[SyntaxKind.Block]]) then
                return CSharpLua.LuaAst.LuaBlockBlockSyntax(block);
            else
                return block;
            end
        end;
        VisitReturnStatement = function (this, node) 
            if System.is(getCurFunction(this), CSharpLua.LuaAst.LuaCheckReturnFunctionExpressionSyntax) then
                local returnStatement = CSharpLua.LuaAst.LuaMultipleReturnStatementSyntax();
                returnStatement.Expressions:Add(CSharpLua.LuaAst.LuaIdentifierNameSyntax.True);
                if node:getExpression() ~= nil then
                    local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    returnStatement.Expressions:Add(expression);
                end
                return returnStatement;
            else
                if node:getExpression() ~= nil then
                    local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    return CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, expression);
                end
                return CSharpLua.LuaAst.LuaReturnStatementSyntax:new(2);
            end
        end;
        VisitExpressionStatement = function (this, node) 
            local expressionNode = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaExpressionStatementSyntax(expressionNode);
        end;
        BuildCommonAssignmentExpression = function (this, left, right, operatorToken) 
            local propertyAdapter = System.as(left, CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax);
            if propertyAdapter ~= nil then
                propertyAdapter.InvocationExpression:AddArgument(CSharpLua.LuaAst.LuaBinaryExpressionSyntax(propertyAdapter:GetCloneOfGet(), operatorToken, right));
                return propertyAdapter;
            else
                return CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(left, CSharpLua.LuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right));
            end
        end;
        BuildDelegateAssignmentExpression = function (this, left, right, isPlus) 
            if System.is(right, CSharpLua.LuaAst.LuaInternalMethodExpressionSyntax) then
                right = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLua.LuaAst.LuaIdentifierNameSyntax.DelegateBind, CSharpLua.LuaAst.LuaIdentifierNameSyntax.This, right);
            elseif System.is(right, CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax) then
                local memberAccess = System.cast(CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax, right);
                if memberAccess:getIsObjectColon() then
                    right = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLua.LuaAst.LuaIdentifierNameSyntax.DelegateBind, memberAccess.Expression, memberAccess.Name);
                end
            end

            local default;
            if isPlus then
                default = CSharpLua.LuaAst.LuaIdentifierNameSyntax.DelegateCombine;
            else
                default = CSharpLua.LuaAst.LuaIdentifierNameSyntax.DelegateRemove;
            end
            local methodName = default;
            local propertyAdapter = System.as(left, CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax);
            if propertyAdapter ~= nil then
                if propertyAdapter:getIsProperty() then
                    propertyAdapter.InvocationExpression:AddArgument(CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, methodName, propertyAdapter:GetCloneOfGet(), right));
                    return propertyAdapter;
                else
                    propertyAdapter:setIsGetOrAdd(isPlus);
                    propertyAdapter.InvocationExpression:AddArgument(right);
                    return propertyAdapter;
                end
            else
                return CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(left, CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, methodName, left, right));
            end
        end;
        BuildLuaAssignmentExpression = function (this, leftNode, rightNode, kind) 
            repeat
                local default = kind;
                if default == 8714 --[[SyntaxKind.SimpleAssignmentExpression]] then
                    
                        local left = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        local right = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));

                        local propertyAdapter = System.as(left, CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax);
                        if propertyAdapter ~= nil then
                            propertyAdapter:setIsGetOrAdd(false);
                            propertyAdapter.InvocationExpression:AddArgument(right);
                            return propertyAdapter;
                        else
                            return CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(left, right);
                        end
                    elseif default == 8715 --[[SyntaxKind.AddAssignmentExpression]] then
                    
                        local leftType = GetTypeInfo(this.semanticModel_, leftNode):getType();
                        if IsStringType(leftType) then
                            local left = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                            local right = WrapStringConcatExpression(this, rightNode);
                            return BuildCommonAssignmentExpression(this, left, right, ".." --[[Tokens.Concatenation]]);
                        else
                            local left = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                            local right = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));

                            if IsDelegateType(leftType) then
                                return BuildDelegateAssignmentExpression(this, left, right, true);
                            else
                                return BuildCommonAssignmentExpression(this, left, right, "+" --[[Tokens.Plus]]);
                            end
                        end
                    elseif default == 8716 --[[SyntaxKind.SubtractAssignmentExpression]] then
                    
                        local left = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, leftNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                        local right = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, rightNode:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));

                        local leftType = GetTypeInfo(this.semanticModel_, leftNode):getType();
                        if IsDelegateType(leftType) then
                            return BuildDelegateAssignmentExpression(this, left, right, false);
                        else
                            return BuildCommonAssignmentExpression(this, left, right, "-" --[[Tokens.Sub]]);
                        end
                    else
                    System.throw(System.NotImplementedException());
                end
            until 1;
        end;
        VisitAssignmentExpression = function (this, node) 
            local assignments = System.List(CSharpLua.LuaAst.LuaExpressionSyntax)();

            while true do
                local leftExpression = node:getLeft();
                local rightExpression = node:getRight();
                local kind = node:Kind();

                local assignmentRight = System.as(rightExpression, Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax);
                if assignmentRight == nil then
                    assignments:Add(BuildLuaAssignmentExpression(this, leftExpression, rightExpression, kind));
                    break;
                else
                    assignments:Add(BuildLuaAssignmentExpression(this, leftExpression, assignmentRight:getLeft(), kind));
                    node = assignmentRight;
                end
            end

            if #assignments == 1 then
                return First(assignments, CSharpLua.LuaAst.LuaExpressionSyntax);
            else
                assignments:Reverse();
                local multipleAssignment = CSharpLua.LuaAst.LuaLineMultipleExpressionSyntax();
                multipleAssignment.Assignments:AddRange(assignments);
                return multipleAssignment;
            end
        end;
        BuildInvokeRefOrOut = function (this, node, invocation, refOrOutArguments) 
            if IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) then
                local multipleAssignment = CSharpLua.LuaAst.LuaMultipleAssignmentExpressionSyntax();
                local symbolInfo = GetSymbolInfo(this.semanticModel_, node);
                local symbol = System.cast(Microsoft.CodeAnalysis.IMethodSymbol, symbolInfo:getSymbol());
                if not symbol:getReturnsVoid() then
                    local temp = GetTempIdentifier(this, node);
                    getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(temp)));
                    multipleAssignment.Lefts:Add(temp);
                end
                multipleAssignment.Lefts:AddRange(refOrOutArguments);
                multipleAssignment.Rights:Add(invocation);
                return multipleAssignment;
            else
                local temp = GetTempIdentifier(this, node);
                local multipleAssignment = CSharpLua.LuaAst.LuaMultipleAssignmentExpressionSyntax();
                multipleAssignment.Lefts:Add(temp);
                multipleAssignment.Lefts:AddRange(refOrOutArguments);
                multipleAssignment.Rights:Add(invocation);

                getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(temp)));
                getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(multipleAssignment));
                return temp;
            end
        end;
        CheckCodeTemplateInvocationExpression = function (this, symbol, node) 
            local constValue = this.semanticModel_:GetConstantValue(node);
            if constValue:getHasValue() then
                return GetConstLiteralExpression(this, constValue:getValue());
            end

            if IsKind(node:getExpression(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                local codeTemplate = getXmlMetaProvider(this):GetMethodCodeTemplate(symbol);
                if codeTemplate ~= nil then
                    local argumentExpressions = System.List(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)();
                    local memberAccessExpression = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax, node:getExpression());
                    if symbol:getIsExtensionMethod() then
                        argumentExpressions:Add(memberAccessExpression:getExpression());
                        if IsSystemLinqEnumerable(symbol:getContainingType()) then
                            getCurCompilationUnit(this):ImportLinq();
                        end
                    end
                    argumentExpressions:AddRange(Linq.Select(node:getArgumentList():getArguments(), function (i) return i:getExpression(); end, Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax));
                    local invocationExpression = BuildCodeTemplateExpression(this, codeTemplate, memberAccessExpression:getExpression(), argumentExpressions, symbol:getTypeArguments());
                    local refOrOuts = Linq.Where(node:getArgumentList():getArguments(), function (i) return IsKind(i:getRefOrOutKeyword(), 8360 --[[SyntaxKind.RefKeyword]]) or IsKind(i:getRefOrOutKeyword(), 8361 --[[SyntaxKind.OutKeyword]]); end);
                    if Linq.Any(refOrOuts) then
                        return BuildInvokeRefOrOut(this, node, invocationExpression, Linq.Select(refOrOuts, function (i) return (System.cast(CSharpLua.LuaAst.LuaArgumentSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode))).Expression; end, CSharpLua.LuaAst.LuaExpressionSyntax));
                    else
                        return invocationExpression;
                    end
                end
            end
            return nil;
        end;
        VisitInvocationExpression = function (this, node) 
            local symbol = System.cast(Microsoft.CodeAnalysis.IMethodSymbol, GetSymbolInfo(this.semanticModel_, node):getSymbol());
            local codeTemplateExpression = CheckCodeTemplateInvocationExpression(this, symbol, node);
            if codeTemplateExpression ~= nil then
                return codeTemplateExpression;
            end

            local arguments = System.List(CSharpLua.LuaAst.LuaArgumentSyntax)();
            local refOrOutArguments = System.List(CSharpLua.LuaAst.LuaExpressionSyntax)();

            for _, argument in System.each(node:getArgumentList():getArguments()) do
                local luaArgument = System.cast(CSharpLua.LuaAst.LuaArgumentSyntax, argument:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                arguments:Add(luaArgument);
                if IsKind(argument:getRefOrOutKeyword(), 8360 --[[SyntaxKind.RefKeyword]]) or IsKind(argument:getRefOrOutKeyword(), 8361 --[[SyntaxKind.OutKeyword]]) then
                    refOrOutArguments:Add(luaArgument.Expression);
                end
            end

            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local invocation;
            if not symbol:getIsExtensionMethod() then
                local memberAccess = System.as(expression, CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax);
                if memberAccess ~= nil then
                    if System.is(memberAccess.Name, CSharpLua.LuaAst.LuaInternalMethodExpressionSyntax) then
                        invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess.Name);
                        invocation:AddArgument(memberAccess.Expression);
                    else
                        invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
                    end
                else
                    invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, expression);
                    invocation:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                end
            else
                local memberAccess = System.cast(CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax, expression);
                local reducedFrom = symbol:getReducedFrom();
                local name = getXmlMetaProvider(this):GetMethodMapName(reducedFrom);
                invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name));
                invocation:AddArgument(memberAccess.Expression);
            end

            invocation.ArgumentList.Arguments:AddRange(arguments);
            if symbol:getTypeArguments():getLength() > 0 then
                local optionalCount = symbol:getParameters():getLength() - node:getArgumentList():getArguments():getCount();
                while optionalCount > 0 do
                    invocation:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.Nil);
                    optionalCount = optionalCount - 1;
                end
                for _, typeArgument in System.each(symbol:getTypeArguments()) do
                    local typeName = getXmlMetaProvider(this):GetTypeName(typeArgument);
                    invocation:AddArgument(typeName);
                end
            end
            if #refOrOutArguments > 0 then
                return BuildInvokeRefOrOut(this, node, invocation, refOrOutArguments);
            end
            return invocation;
        end;
        BuildMemberAccessTargetExpression = function (this, targetExpression) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, targetExpression:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local kind = targetExpression:Kind();
            if (kind >= 8749 --[[SyntaxKind.NumericLiteralExpression]] and kind <= 8754 --[[SyntaxKind.NullLiteralExpression]]) or (System.is(expression, CSharpLua.LuaAst.LuaLiteralExpressionSyntax)) then
                expression = CSharpLua.LuaAst.LuaParenthesizedExpressionSyntax(expression);
            end
            return expression;
        end;
        CheckMemberAccessCodeTemplate = function (this, symbol, node) 
            if symbol:getKind() == 6 --[[SymbolKind.Field]] then
                local fieldSymbol = System.cast(Microsoft.CodeAnalysis.IFieldSymbol, symbol);
                local codeTemplate = getXmlMetaProvider(this):GetFieldCodeTemplate(fieldSymbol);
                if codeTemplate ~= nil then
                    return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, codeTemplate);
                end

                if fieldSymbol:getHasConstantValue() then
                    return GetConstLiteralExpression(this, fieldSymbol);
                end
            elseif symbol:getKind() == 15 --[[SymbolKind.Property]] then
                local propertySymbol = System.cast(Microsoft.CodeAnalysis.IPropertySymbol, symbol);
                local isGet = not IsAssignment(Kind(node:getParent()));
                local codeTemplate = getXmlMetaProvider(this):GetProertyCodeTemplate(propertySymbol, isGet);
                if codeTemplate ~= nil then
                    return BuildCodeTemplateExpression(this, codeTemplate, node:getExpression());
                end
            end
            return nil;
        end;
        VisitMemberAccessExpression = function (this, node) 
            local symbol = GetSymbolInfo(this.semanticModel_, node):getSymbol();
            local codeTemplateExpression = CheckMemberAccessCodeTemplate(this, symbol, node);
            if codeTemplateExpression ~= nil then
                return codeTemplateExpression;
            end

            if symbol:getKind() == 15 --[[SymbolKind.Property]] or symbol:getKind() == 5 --[[SymbolKind.Event]] then
                if IsKind(node:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
                    local propertyIdentifier = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    local propertyAdapter = System.as(propertyIdentifier, CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax);
                    if propertyAdapter ~= nil then
                        return propertyAdapter;
                    else
                        return CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This, propertyIdentifier);
                    end
                end

                if IsKind(node:getExpression(), 8747 --[[SyntaxKind.BaseExpression]]) then
                    local expression = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    local nameIdentifier = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    local propertyMethod = System.as(nameIdentifier, CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax);
                    if propertyMethod ~= nil then
                        if expression ~= CSharpLua.LuaAst.LuaIdentifierNameSyntax.This then
                            propertyMethod.InvocationExpression:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                        end

                        local memberAccessExpression = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, propertyMethod.InvocationExpression.Expression, true);
                        propertyMethod:Update(memberAccessExpression);
                        return propertyMethod;
                    else
                        return CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, nameIdentifier);
                    end
                else
                    local expression = BuildMemberAccessTargetExpression(this, node:getExpression());
                    local nameExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    local propertyMethod = System.as(nameExpression, CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax);
                    if propertyMethod ~= nil then
                        local arguments = propertyMethod.InvocationExpression.ArgumentList.Arguments;
                        if #arguments == 1 then
                            if arguments:get(0).Expression == CSharpLua.LuaAst.LuaIdentifierNameSyntax.This then
                                propertyMethod.InvocationExpression.ArgumentList.Arguments:set(0, CSharpLua.LuaAst.LuaArgumentSyntax(expression));
                            end
                        else
                            local memberAccessExpression = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, propertyMethod.InvocationExpression.Expression, not symbol:getIsStatic());
                            propertyMethod:Update(memberAccessExpression);
                        end
                        return propertyMethod;
                    else
                        return CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, nameExpression);
                    end
                end
            else
                if IsKind(node:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
                    return node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode);
                end

                if IsKind(node:getExpression(), 8747 --[[SyntaxKind.BaseExpression]]) then
                    local baseExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    local identifier = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    if baseExpression == CSharpLua.LuaAst.LuaIdentifierNameSyntax.This then
                        return CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(baseExpression, identifier, symbol:getKind() == 9 --[[SymbolKind.Method]]);
                    else
                        local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(baseExpression, identifier);
                        return CSharpLua.LuaAst.LuaInternalMethodExpressionSyntax(memberAccess);
                    end
                else
                    local expression = BuildMemberAccessTargetExpression(this, node:getExpression());
                    local identifier = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getName():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    return CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(expression, identifier, not symbol:getIsStatic() and symbol:getKind() == 9 --[[SymbolKind.Method]]);
                end
            end
        end;
        BuildStaticFieldName = function (this, symbol, isReadOnly, node) 
            assert(symbol:getIsStatic());
            local name;
            if symbol:getDeclaredAccessibility() == 1 --[[Accessibility.Private]] then
                name = symbol:getName();
            else
                if isReadOnly then
                    name = symbol:getName();
                    if IsKind(node:getParent(), 8714 --[[SyntaxKind.SimpleAssignmentExpression]]) then
                        local assignmentExpression = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax, node:getParent());
                        if assignmentExpression:getLeft() == node then
                            getCurType(this):AddStaticReadOnlyAssignmentName(name);
                        end
                    end
                else
                    local constructor = System.as(getCurFunction(this), CSharpLua.LuaAst.LuaConstructorAdapterExpressionSyntax);
                    if constructor ~= nil and constructor.IsStaticCtor then
                        name = "this" --[[Tokens.This]] .. '.' .. (symbol:getName() or "");
                    else
                        if IsInternalNode(this, node) then
                            name = symbol:ToString();
                        else
                            name = symbol:getName();
                        end
                    end
                end
            end
            return name;
        end;
        IsInternalNode = function (this, node) 
            local isInternal = false;
            local parent = nil;
            if IsKind(node:getParent(), 8689 --[[SyntaxKind.SimpleMemberAccessExpression]]) then
                parent = System.cast(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax, node:getParent());
            end
            if parent ~= nil then
                if IsKind(parent:getExpression(), 8746 --[[SyntaxKind.ThisExpression]]) then
                    isInternal = true;
                elseif parent:getExpression() == node then
                    isInternal = true;
                end
            else
                isInternal = true;
            end
            return isInternal;
        end;
        VisitFieldOrEventIdentifierName = function (this, node, symbol, isProperty) 
            local name;
            local isField, isReadOnly;
            if isProperty then
                local propertySymbol = System.cast(Microsoft.CodeAnalysis.IPropertySymbol, symbol);
                isField = IsPropertyField(this, propertySymbol);
                isReadOnly = propertySymbol:getIsReadOnly();
            else
                local eventSymbol = System.cast(Microsoft.CodeAnalysis.IEventSymbol, symbol);
                isField = IsEventFiled(eventSymbol);
                isReadOnly = false;
            end

            if symbol:getIsStatic() then
                if isField then
                    name = BuildStaticFieldName(this, symbol, isReadOnly, node);
                else
                    return CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax:new(1, CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName()));
                end
            else
                if isField then
                    if IsInternalNode(this, node) then
                        name = "this" --[[Tokens.This]] .. '.' .. (symbol:getName() or "");
                    else
                        name = symbol:getName();
                    end
                else
                    if IsInternalMember(this, node, symbol) then
                        local propertyAdapter = CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax:new(1, CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName()));
                        propertyAdapter.InvocationExpression:AddArgument(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This);
                        return propertyAdapter;
                    else
                        if IsInternalNode(this, node) then
                            local identifierName = CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName());
                            local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This, identifierName, true);
                            return CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax:new(2, memberAccess, identifierName);
                        else
                            return CSharpLua.LuaAst.LuaPropertyAdapterExpressionSyntax:new(1, CSharpLua.LuaAst.LuaPropertyOrEventIdentifierNameSyntax(isProperty, symbol:getName()));
                        end
                    end
                end
            end
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        GetMethodNameExpression = function (this, symbol, node) 
            local name;
            local methodName = getXmlMetaProvider(this):GetMethodMapName(symbol);
            if symbol:getIsStatic() then
                name = methodName;
            else
                if IsInternalMember(this, node, symbol) then
                    return CSharpLua.LuaAst.LuaInternalMethodExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, methodName));
                else
                    if IsInternalNode(this, node) then
                        local identifierName = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, methodName);
                        local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.This, identifierName, true);
                        return memberAccess;
                    else
                        name = methodName;
                    end
                end
            end
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        VisitIdentifierName = function (this, node) 
            local symbolInfo = GetSymbolInfo(this.semanticModel_, node);
            local symbol = symbolInfo:getSymbol();
            assert(symbol ~= nil);
            local name;
            repeat
                local default = symbol:getKind();
                if default == 8 --[[SymbolKind.Local]] or default == 13 --[[SymbolKind.Parameter]] then
                    
                        name = symbol:getName();
                        name = CheckReservedWord(this, name, symbol);
                        break;
                    elseif default == 17 --[[SymbolKind.TypeParameter]] or default == 7 --[[SymbolKind.Label]] then
                    
                        name = symbol:getName();
                        break;
                    elseif default == 12 --[[SymbolKind.Namespace]] or default == 11 --[[SymbolKind.NamedType]] then
                    
                        name = symbol:ToString();
                        break;
                    elseif default == 6 --[[SymbolKind.Field]] then
                    
                        if symbol:getIsStatic() then
                            local fieldSymbol = System.cast(Microsoft.CodeAnalysis.IFieldSymbol, symbol);
                            if fieldSymbol:getHasConstantValue() then
                                if fieldSymbol:getType():getSpecialType() == 20 --[[SpecialType.System_String]] then
                                    if #(System.cast(System.String, fieldSymbol:getConstantValue())) < 25 --[[LuaSyntaxNode.StringConstInlineCount]] then
                                        return GetConstLiteralExpression(this, fieldSymbol);
                                    end
                                else
                                    return GetConstLiteralExpression(this, fieldSymbol);
                                end
                            end
                            name = BuildStaticFieldName(this, symbol, fieldSymbol:getIsReadOnly(), node);
                        else
                            if IsInternalNode(this, node) then
                                name = "this" --[[Tokens.This]] .. '.' .. (symbol:getName() or "");
                            else
                                name = symbol:getName();
                            end
                        end
                        break;
                    elseif default == 9 --[[SymbolKind.Method]] then
                    
                        return GetMethodNameExpression(this, System.cast(Microsoft.CodeAnalysis.IMethodSymbol, symbol), node);
                    elseif default == 15 --[[SymbolKind.Property]] then
                    
                        return VisitFieldOrEventIdentifierName(this, node, symbol, true);
                    elseif default == 5 --[[SymbolKind.Event]] then
                    
                        return VisitFieldOrEventIdentifierName(this, node, symbol, false);
                    else
                    
                        System.throw(System.NotSupportedException());
                    end
            until 1;
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, name);
        end;
        VisitQualifiedName = function (this, node) 
            return CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:ToString());
        end;
        BuildArgumentList = function (this, arguments) 
            local argumentList = CSharpLua.LuaAst.LuaArgumentListSyntax();
            for _, argument in System.each(arguments) do
                local newNode = System.cast(CSharpLua.LuaAst.LuaArgumentSyntax, argument:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                argumentList.Arguments:Add(newNode);
            end
            return argumentList;
        end;
        VisitArgumentList = function (this, node) 
            return BuildArgumentList(this, node:getArguments());
        end;
        VisitArgument = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local argument = CSharpLua.LuaAst.LuaArgumentSyntax(expression);
            return argument;
        end;
        VisitLiteralExpression = function (this, node) 
            repeat
                local default = node:Kind();
                if default == 8751 --[[SyntaxKind.CharacterLiteralExpression]] then
                    
                        return CSharpLua.LuaAst.LuaCharacterLiteralExpression(System.cast(System.Char, node:getToken():getValue()));
                    elseif default == 8754 --[[SyntaxKind.NullLiteralExpression]] then
                    
                        return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(2, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Nil);
                    elseif default == 8750 --[[SyntaxKind.StringLiteralExpression]] then
                    
                        return BuildStringLiteralTokenExpression(this, node:getToken());
                    else
                    
                        return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, node:getToken():getValueText());
                    end
            until 1;
        end;
        VisitLocalDeclarationStatement = function (this, node) 
            local declaration = System.cast(CSharpLua.LuaAst.LuaVariableDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaLocalDeclarationStatementSyntax(declaration);
        end;
        VisitVariableDeclaration = function (this, node) 
            local variableListDeclaration = CSharpLua.LuaAst.LuaVariableListDeclarationSyntax();
            for _, variable in System.each(node:getVariables()) do
                local variableDeclarator = System.cast(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax, variable:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                variableListDeclaration.Variables:Add(variableDeclarator);
            end
            local isMultiNil = #variableListDeclaration.Variables > 0 and Linq.All(variableListDeclaration.Variables, function (i) return i.Initializer == nil; end);
            if isMultiNil then
                local declarationStatement = CSharpLua.LuaAst.LuaLocalVariablesStatementSyntax();
                for _, variable in System.each(variableListDeclaration.Variables) do
                    declarationStatement.Variables:Add(variable.Identifier);
                end
                return declarationStatement;
            else
                return variableListDeclaration;
            end
        end;
        VisitVariableDeclarator = function (this, node) 
            local identifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            identifier = CheckVariableDeclaratorName(this, identifier, node);
            local variableDeclarator = CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(identifier);
            if node:getInitializer() ~= nil then
                variableDeclarator.Initializer = System.cast(CSharpLua.LuaAst.LuaEqualsValueClauseSyntax, node:getInitializer():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            end
            return variableDeclarator;
        end;
        VisitEqualsValueClause = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getValue():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaEqualsValueClauseSyntax(expression);
        end;
        VisitPredefinedType = function (this, node) 
            local symbol = GetSymbolInfo(this.semanticModel_, node):getSymbol();
            return getXmlMetaProvider(this):GetTypeShortName(symbol);
        end;
        WriteStatementOrBlock = function (this, statement, block) 
            if IsKind(statement, 8792 --[[SyntaxKind.Block]]) then
                local blockNode = System.cast(CSharpLua.LuaAst.LuaBlockSyntax, statement:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                block.Statements:AddRange(blockNode.Statements);
            else
                this.blocks_:Push(block);
                local statementNode = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                block.Statements:Add(statementNode);
                this.blocks_:Pop();
            end
        end;
        VisitIfStatement = function (this, node) 
            local condition = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local ifStatement = CSharpLua.LuaAst.LuaIfStatementSyntax(condition);
            WriteStatementOrBlock(this, node:getStatement(), ifStatement.Body);
            ifStatement.Else = System.cast(CSharpLua.LuaAst.LuaElseClauseSyntax, System.access(node:getElse(), function (default) return this:Accept; end(this, this, CSharpLua.LuaAst.LuaSyntaxNode)));
            return ifStatement;
        end;
        VisitElseClause = function (this, node) 
            local statement;
            if IsKind(node:getStatement(), 8819 --[[SyntaxKind.IfStatement]]) then
                statement = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, node:getStatement():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            else
                local block = CSharpLua.LuaAst.LuaBlockSyntax();
                WriteStatementOrBlock(this, node:getStatement(), block);
                statement = block;
            end
            local elseClause = CSharpLua.LuaAst.LuaElseClauseSyntax(statement);
            return elseClause;
        end;
        VisitSwitchStatement = function (this, node) 
            local temp = GetTempIdentifier(this, node);
            local switchStatement = CSharpLua.LuaAst.LuaSwitchAdapterStatementSyntax(temp);
            this.switchs_:Push(switchStatement);
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            switchStatement:Fill(expression, Linq.Select(node:getSections(), function (i) return System.cast(CSharpLua.LuaAst.LuaStatementSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode)); end, CSharpLua.LuaAst.LuaStatementSyntax));
            this.switchs_:Pop();
            return switchStatement;
        end;
        VisitSwitchSection = function (this, node) 
            local isDefault = Linq.Any(node:getLabels(), function (i) return i:Kind() == 8824 --[[SyntaxKind.DefaultSwitchLabel]]; end);
            if isDefault then
                local block = CSharpLua.LuaAst.LuaBlockSyntax();
                for _, statement in System.each(node:getStatements()) do
                    local luaStatement = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    block.Statements:Add(luaStatement);
                end
                return block;
            else
                local expressions = Linq.Select(node:getLabels(), function (i) return System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode)); end, CSharpLua.LuaAst.LuaExpressionSyntax);
                local condition = Linq.Aggregate(expressions, function (x, y) return CSharpLua.LuaAst.LuaBinaryExpressionSyntax(x, "or" --[[Keyword.Or]], y); end);
                local ifStatement = CSharpLua.LuaAst.LuaIfStatementSyntax(condition);
                for _, statement in System.each(node:getStatements()) do
                    local luaStatement = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, statement:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                    ifStatement.Body.Statements:Add(luaStatement);
                end
                return ifStatement;
            end
        end;
        VisitCaseSwitchLabel = function (this, node) 
            local left = this.switchs_:Peek().Temp;
            local right = System.cast(CSharpLua.LuaAst.LuaLiteralExpressionSyntax, node:getValue():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local BinaryExpression = CSharpLua.LuaAst.LuaBinaryExpressionSyntax(left, "==" --[[Tokens.EqualsEquals]], right);
            return BinaryExpression;
        end;
        VisitBreakStatement = function (this, node) 
            return CSharpLua.LuaAst.LuaBreakStatementSyntax.Statement;
        end;
        WrapStringConcatExpression = function (this, expression) 
            local typeInfo = GetTypeInfo(this.semanticModel_, expression):getType();
            local original = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, expression:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            if IsStringType(typeInfo) then
                if System.is(expression, Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax) then
                    return original;
                end

                local constValue = this.semanticModel_:GetConstantValue(expression);
                if constValue:getHasValue() then
                    return original;
                else
                    local binaryExpression = CSharpLua.LuaAst.LuaBinaryExpressionSyntax(original, "or" --[[Keyword.Or]], CSharpLua.LuaAst.LuaStringLiteralExpressionSyntax.Empty);
                    return CSharpLua.LuaAst.LuaParenthesizedExpressionSyntax(binaryExpression);
                end
            elseif typeInfo:getSpecialType() == 8 --[[SpecialType.System_Char]] then
                local constValue = this.semanticModel_:GetConstantValue(expression);
                if constValue:getHasValue() then
                    local text = Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.cast(System.Char, constValue:getValue())):getText();
                    return CSharpLua.LuaAst.LuaIdentifierLiteralExpressionSyntax:new(1, text);
                else
                    return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, CSharpLua.LuaAst.LuaIdentifierNameSyntax.StringChar, original);
                end
            elseif typeInfo:getSpecialType() >= 7 --[[SpecialType.System_Boolean]] and typeInfo:getSpecialType() <= 19 --[[SpecialType.System_Double]] then
                return original;
            elseif typeInfo:getTypeKind() == 5 --[[TypeKind.Enum]] then
                local symbol = GetSymbolInfo(this.semanticModel_, expression):getSymbol();
                if System.is(original, CSharpLua.LuaAst.LuaLiteralExpressionSyntax) then
                    return CSharpLua.LuaAst.LuaConstLiteralExpression:new(1, symbol:getName(), symbol:ToString());
                else
                    this.generator_:AddExportEnum(symbol:ToString());
                    local typeName = getXmlMetaProvider(this):GetTypeShortName(typeInfo);
                    local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, symbol:getName()), CSharpLua.LuaAst.LuaIdentifierNameSyntax.ToEnumString, true);
                    return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(2, memberAccess, typeName);
                end
            elseif typeInfo:getIsValueType() then
                local memberAccess = CSharpLua.LuaAst.LuaMemberAccessExpressionSyntax(original, CSharpLua.LuaAst.LuaIdentifierNameSyntax.ToStr, true);
                return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, memberAccess);
            else
                local invocation = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaIdentifierNameSyntax.StringConcat);
                invocation:AddArgument(original);
                return invocation;
            end
        end;
        BuildStringConcatExpression = function (this, node) 
            return BuildStringConcatExpression(this, node:getLeft(), node:getRight());
        end;
        BuildStringConcatExpression = function (this, leftNode, rightNode) 
            local left = WrapStringConcatExpression(this, leftNode);
            local right = WrapStringConcatExpression(this, rightNode);
            return CSharpLua.LuaAst.LuaBinaryExpressionSyntax(left, ".." --[[Tokens.Concatenation]], right);
        end;
        BuildBinaryInvokeExpression = function (this, node, name) 
            local left = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local right = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, name, left, right);
        end;
        BuildIntegerDivExpression = function (this, node) 
            if getIsLuaNewest(this) then
                return BuildBinaryExpression(this, node, "//" --[[Tokens.Div]]);
            else
                return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.IntegerDiv);
            end
        end;
        BuildBinaryExpression = function (this, node, operatorToken) 
            local left = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getLeft():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local right = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getRight():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaBinaryExpressionSyntax(left, operatorToken, right);
        end;
        BuildBitExpression = function (this, node, boolOperatorToken, otherName) 
            local leftType = GetTypeInfo(this.semanticModel_, node:getLeft()):getType();
            if leftType:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
                return BuildBinaryExpression(this, node, boolOperatorToken);
            elseif not getIsLuaNewest(this) then
                return BuildBinaryInvokeExpression(this, node, otherName);
            else
                local operatorToken = GetOperatorToken(this, node:getOperatorToken());
                return BuildBinaryExpression(this, node, operatorToken);
            end
        end;
        VisitBinaryExpression = function (this, node) 
            repeat
                local default = node:Kind();
                if default == 8668 --[[SyntaxKind.AddExpression]] then
                    
                        local methodSymbol = System.as(GetSymbolInfo(this.semanticModel_, node):getSymbol(), Microsoft.CodeAnalysis.IMethodSymbol);
                        if methodSymbol ~= nil then
                            if IsStringType(methodSymbol:getContainingType()) then
                                return BuildStringConcatExpression(this, node);
                            elseif IsDelegateType(methodSymbol:getContainingType()) then
                                return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.DelegateCombine);
                            end
                        end
                        break;
                    elseif default == 8669 --[[SyntaxKind.SubtractExpression]] then
                    
                        local methodSymbol = System.as(GetSymbolInfo(this.semanticModel_, node):getSymbol(), Microsoft.CodeAnalysis.IMethodSymbol);
                        if methodSymbol ~= nil and IsDelegateType(methodSymbol:getContainingType()) then
                            return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.DelegateRemove);
                        end
                        break;
                    elseif default == 8671 --[[SyntaxKind.DivideExpression]] then
                    
                        local leftType = GetTypeInfo(this.semanticModel_, node:getLeft()):getType();
                        local rightType = GetTypeInfo(this.semanticModel_, node:getRight()):getType();
                        if IsIntegerType(leftType) and IsIntegerType(rightType) then
                            return BuildIntegerDivExpression(this, node);
                        end
                        break;
                    elseif default == 8672 --[[SyntaxKind.ModuloExpression]] then
                    
                        if not getIsLuaNewest(this) then
                            local leftType = GetTypeInfo(this.semanticModel_, node:getLeft()):getType();
                            local rightType = GetTypeInfo(this.semanticModel_, node:getRight()):getType();
                            if IsIntegerType(leftType) and IsIntegerType(rightType) then
                                return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.IntegerMod);
                            end
                        end
                        break;
                    elseif default == 8673 --[[SyntaxKind.LeftShiftExpression]] then
                    
                        if not getIsLuaNewest(this) then
                            return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.ShiftLeft);
                        end
                        break;
                    elseif default == 8674 --[[SyntaxKind.RightShiftExpression]] then
                    
                        if not getIsLuaNewest(this) then
                            return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.ShiftRight);
                        end
                        break;
                    elseif default == 8677 --[[SyntaxKind.BitwiseOrExpression]] then
                    
                        return BuildBitExpression(this, node, "or" --[[Keyword.Or]], CSharpLua.LuaAst.LuaIdentifierNameSyntax.BitOr);
                    elseif default == 8678 --[[SyntaxKind.BitwiseAndExpression]] then
                    
                        return BuildBitExpression(this, node, "and" --[[Keyword.And]], CSharpLua.LuaAst.LuaIdentifierNameSyntax.BitAnd);
                    elseif default == 8679 --[[SyntaxKind.ExclusiveOrExpression]] then
                    
                        return BuildBitExpression(this, node, "~=" --[[Tokens.NotEquals]], CSharpLua.LuaAst.LuaIdentifierNameSyntax.BitXor);
                    elseif default == 8686 --[[SyntaxKind.IsExpression]] then
                    
                        return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Is);
                    elseif default == 8687 --[[SyntaxKind.AsExpression]] then
                    
                        return BuildBinaryInvokeExpression(this, node, CSharpLua.LuaAst.LuaIdentifierNameSyntax.As);
                    end
            until 1;
            local operatorToken = GetOperatorToken(this, node:getOperatorToken());
            return BuildBinaryExpression(this, node, operatorToken);
        end;
        GetLuaAssignmentExpressionSyntax = function (this, operand, isPlus) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, operand:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local operatorToken = isPlus and "+" --[[Tokens.Plus]] or "-" --[[Tokens.Sub]];
            local binary = CSharpLua.LuaAst.LuaBinaryExpressionSyntax(expression, operatorToken, CSharpLua.LuaAst.LuaIdentifierNameSyntax.One);
            local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(expression, binary);
            return assignment;
        end;
        VisitPrefixUnaryExpression = function (this, node) 
            local kind = node:Kind();
            if kind == 8734 --[[SyntaxKind.PreIncrementExpression]] or kind == 8735 --[[SyntaxKind.PreDecrementExpression]] then
                local assignment = GetLuaAssignmentExpressionSyntax(this, node:getOperand(), kind == 8734 --[[SyntaxKind.PreIncrementExpression]]);
                if IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) or IsKind(node:getParent(), 8811 --[[SyntaxKind.ForStatement]]) then
                    return assignment;
                else
                    getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
                    return assignment.Left;
                end
            else
                local operand = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getOperand():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local operatorToken = GetOperatorToken(this, node:getOperatorToken());
                local unaryExpression = CSharpLua.LuaAst.LuaPrefixUnaryExpressionSyntax(operand, operatorToken);
                return unaryExpression;
            end
        end;
        VisitPostfixUnaryExpression = function (this, node) 
            local kind = node:Kind();
            if kind ~= 8738 --[[SyntaxKind.PostIncrementExpression]] and kind ~= 8739 --[[SyntaxKind.PostDecrementExpression]] then
                System.throw(System.NotSupportedException());
            end
            local assignment = GetLuaAssignmentExpressionSyntax(this, node:getOperand(), kind == 8738 --[[SyntaxKind.PostIncrementExpression]]);
            if IsKind(node:getParent(), 8797 --[[SyntaxKind.ExpressionStatement]]) or IsKind(node:getParent(), 8811 --[[SyntaxKind.ForStatement]]) then
                return assignment;
            else
                local temp = GetTempIdentifier(this, node);
                local variableDeclarator = CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(temp);
                variableDeclarator.Initializer = CSharpLua.LuaAst.LuaEqualsValueClauseSyntax(assignment.Left);
                getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(variableDeclarator));
                getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
                return temp;
            end
        end;
        VisitContinueStatement = function (this, node) 
            return CSharpLua.LuaAst.LuaContinueAdapterStatementSyntax.Statement;
        end;
        VisitLoopBody = function (this, bodyStatement, block) 
            local hasContinue = IsContinueExists(this, bodyStatement);
            if hasContinue then
                -- http://lua-users.org/wiki/ContinueProposal
                local continueIdentifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax.Continue;
                block.Statements:Add(CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(continueIdentifier)));
                local repeatStatement = CSharpLua.LuaAst.LuaRepeatStatementSyntax(CSharpLua.LuaAst.LuaIdentifierNameSyntax.One);
                WriteStatementOrBlock(this, bodyStatement, repeatStatement.Body);
                local assignment = CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(continueIdentifier, CSharpLua.LuaAst.LuaIdentifierNameSyntax.True);
                repeatStatement.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(assignment));
                block.Statements:Add(repeatStatement);
                local IfStatement = CSharpLua.LuaAst.LuaIfStatementSyntax(CSharpLua.LuaAst.LuaPrefixUnaryExpressionSyntax(continueIdentifier, "not" --[[Keyword.Not]]));
                IfStatement.Body.Statements:Add(CSharpLua.LuaAst.LuaBreakStatementSyntax.Statement);
                block.Statements:Add(IfStatement);
            else
                WriteStatementOrBlock(this, bodyStatement, block);
            end
        end;
        VisitForEachStatement = function (this, node) 
            local identifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local forInStatement = CSharpLua.LuaAst.LuaForInStatementSyntax(identifier, expression);
            VisitLoopBody(this, node:getStatement(), forInStatement.Body);
            return forInStatement;
        end;
        VisitWhileStatement = function (this, node) 
            local condition = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local whileStatement = CSharpLua.LuaAst.LuaWhileStatementSyntax(condition);
            VisitLoopBody(this, node:getStatement(), whileStatement.Body);
            return whileStatement;
        end;
        VisitForStatement = function (this, node) 
            local body = CSharpLua.LuaAst.LuaBlockSyntax();
            this.blocks_:Push(body);

            if node:getDeclaration() ~= nil then
                body.Statements:Add(System.cast(CSharpLua.LuaAst.LuaVariableDeclarationSyntax, node:getDeclaration():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode)));
            end
            local initializers = Linq.Select(node:getInitializers(), function (i) return CSharpLua.LuaAst.LuaExpressionStatementSyntax(System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode))); end, CSharpLua.LuaAst.LuaExpressionStatementSyntax);
            body.Statements:AddRange(initializers);

            local default;
            if node:getCondition() ~= nil then
                default = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            else
                default = CSharpLua.LuaAst.LuaIdentifierNameSyntax.True;
            end
            local condition = default;
            local whileStatement = CSharpLua.LuaAst.LuaWhileStatementSyntax(condition);
            this.blocks_:Push(whileStatement.Body);
            VisitLoopBody(this, node:getStatement(), whileStatement.Body);
            local incrementors = Linq.Select(node:getIncrementors(), function (i) return CSharpLua.LuaAst.LuaExpressionStatementSyntax(System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, i:Accept(this, CSharpLua.LuaAst.LuaSyntaxNode))); end, CSharpLua.LuaAst.LuaExpressionStatementSyntax);
            whileStatement.Body.Statements:AddRange(incrementors);
            this.blocks_:Pop();
            body.Statements:Add(whileStatement);
            this.blocks_:Pop();

            return CSharpLua.LuaAst.LuaBlockBlockSyntax(body);
        end;
        VisitDoStatement = function (this, node) 
            local condition = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local newCondition = CSharpLua.LuaAst.LuaPrefixUnaryExpressionSyntax(CSharpLua.LuaAst.LuaParenthesizedExpressionSyntax(condition), "not" --[[Keyword.Not]]);
            local repeatStatement = CSharpLua.LuaAst.LuaRepeatStatementSyntax(newCondition);
            VisitLoopBody(this, node:getStatement(), repeatStatement.Body);
            return repeatStatement;
        end;
        VisitYieldStatement = function (this, node) 
            getCurFunction(this).HasYield = true;
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            if IsKind(node, 8807 --[[SyntaxKind.YieldBreakStatement]]) then
                local returnStatement = CSharpLua.LuaAst.LuaReturnStatementSyntax:new(1, expression);
                return returnStatement;
            else
                local invocationExpression = CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(1, CSharpLua.LuaAst.LuaIdentifierNameSyntax.YieldReturn);
                invocationExpression:AddArgument(expression);
                return CSharpLua.LuaAst.LuaExpressionStatementSyntax(invocationExpression);
            end
        end;
        VisitParenthesizedExpression = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaParenthesizedExpressionSyntax(expression);
        end;
        MayBeNullOrFalse = function (this, conditionalWhenTrue) 
            local type = GetTypeInfo(this.semanticModel_, conditionalWhenTrue):getType();
            local mayBeNullOrFalse;
            if type:getIsValueType() then
                if type:getSpecialType() == 7 --[[SpecialType.System_Boolean]] then
                    local constValue = this.semanticModel_:GetConstantValue(conditionalWhenTrue);
                    if constValue:getHasValue() and System.cast(System.Boolean, constValue:getValue()) then
                        mayBeNullOrFalse = false;
                    else
                        mayBeNullOrFalse = true;
                    end
                else
                    mayBeNullOrFalse = false;
                end
            elseif IsStringType(type) then
                local constValue = this.semanticModel_:GetConstantValue(conditionalWhenTrue);
                if constValue:getHasValue() then
                    mayBeNullOrFalse = false;
                else
                    mayBeNullOrFalse = true;
                end
            else
                mayBeNullOrFalse = true;
            end
            return mayBeNullOrFalse;
        end;
        VisitConditionalExpression = function (this, node) 
            local mayBeNullOrFalse = MayBeNullOrFalse(this, node:getWhenTrue());
            if mayBeNullOrFalse then
                local temp = GetTempIdentifier(this, node);
                local condition = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local ifStatement = CSharpLua.LuaAst.LuaIfStatementSyntax(condition);
                this.blocks_:Push(ifStatement.Body);
                local whenTrue = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getWhenTrue():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                this.blocks_:Pop();
                ifStatement.Body.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(temp, whenTrue)));

                local block = CSharpLua.LuaAst.LuaBlockSyntax();
                this.blocks_:Push(block);
                local whenFalse = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getWhenFalse():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                this.blocks_:Pop();
                block.Statements:Add(CSharpLua.LuaAst.LuaExpressionStatementSyntax(CSharpLua.LuaAst.LuaAssignmentExpressionSyntax(temp, whenFalse)));

                ifStatement.Else = CSharpLua.LuaAst.LuaElseClauseSyntax(block);
                getCurBlock(this).Statements:Add(CSharpLua.LuaAst.LuaLocalVariableDeclaratorSyntax(CSharpLua.LuaAst.LuaVariableDeclaratorSyntax(temp)));
                getCurBlock(this).Statements:Add(ifStatement);
                return temp;
            else
                local condition = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getCondition():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local whenTrue = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getWhenTrue():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                local whenFalse = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getWhenFalse():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                return CSharpLua.LuaAst.LuaBinaryExpressionSyntax(CSharpLua.LuaAst.LuaBinaryExpressionSyntax(condition, "and" --[[Keyword.And]], whenTrue), "or" --[[Keyword.Or]], whenFalse);
            end
        end;
        VisitGotoStatement = function (this, node) 
            if IsKind(node:getCaseOrDefaultKeyword(), 8332 --[[SyntaxKind.CaseKeyword]]) then
                local kCaseLabel = "caseLabel";
                local switchStatement = this.switchs_:Peek();
                local caseIndex = GetCaseLabelIndex(this, node);
                local labelIdentifier = GetOrDefault(switchStatement.CaseLabels, caseIndex, nil, System.Int, CSharpLua.LuaAst.LuaIdentifierNameSyntax);
                if labelIdentifier == nil then
                    local uniqueName = GetUniqueIdentifier(this, kCaseLabel .. caseIndex, node);
                    labelIdentifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, uniqueName);
                    switchStatement.CaseLabels:Add(caseIndex, labelIdentifier);
                end
                return CSharpLua.LuaAst.LuaGotoCaseAdapterStatement(labelIdentifier);
            elseif IsKind(node:getCaseOrDefaultKeyword(), 8333 --[[SyntaxKind.DefaultKeyword]]) then
                local kDefaultLabel = "defaultLabel";
                local switchStatement = this.switchs_:Peek();
                if switchStatement.DefaultLabel == nil then
                    local identifier = GetUniqueIdentifier(this, kDefaultLabel, node);
                    switchStatement.DefaultLabel = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, identifier);
                end
                return CSharpLua.LuaAst.LuaGotoCaseAdapterStatement(switchStatement.DefaultLabel);
            else
                local identifier = System.cast(CSharpLua.LuaAst.LuaIdentifierNameSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
                return CSharpLua.LuaAst.LuaGotoStatement(identifier);
            end
        end;
        VisitLabeledStatement = function (this, node) 
            local identifier = CSharpLua.LuaAst.LuaIdentifierNameSyntax:new(1, node:getIdentifier():getValueText());
            local statement = System.cast(CSharpLua.LuaAst.LuaStatementSyntax, node:getStatement():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaLabeledStatement(identifier, statement);
        end;
        VisitEmptyStatement = function (this, node) 
            return CSharpLua.LuaAst.LuaStatementSyntax.Empty;
        end;
        VisitCastExpression = function (this, node) 
            local expression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getExpression():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            local typeExpression = System.cast(CSharpLua.LuaAst.LuaExpressionSyntax, node:getType():Accept(this, CSharpLua.LuaAst.LuaSyntaxNode));
            return CSharpLua.LuaAst.LuaInvocationExpressionSyntax:new(3, CSharpLua.LuaAst.LuaIdentifierNameSyntax.Cast, typeExpression, expression);
        end;
        return {
            __inherits__ = {
                Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor_1(CSharpLua.LuaAst.LuaSyntaxNode)
            }, 
            VisitCompilationUnit = VisitCompilationUnit, 
            VisitNamespaceDeclaration = VisitNamespaceDeclaration, 
            VisitClassDeclaration = VisitClassDeclaration, 
            VisitStructDeclaration = VisitStructDeclaration, 
            VisitInterfaceDeclaration = VisitInterfaceDeclaration, 
            VisitEnumDeclaration = VisitEnumDeclaration, 
            VisitMethodDeclaration = VisitMethodDeclaration, 
            VisitFieldDeclaration = VisitFieldDeclaration, 
            VisitPropertyDeclaration = VisitPropertyDeclaration, 
            VisitEventDeclaration = VisitEventDeclaration, 
            VisitEventFieldDeclaration = VisitEventFieldDeclaration, 
            VisitEnumMemberDeclaration = VisitEnumMemberDeclaration, 
            VisitIndexerDeclaration = VisitIndexerDeclaration, 
            VisitParameterList = VisitParameterList, 
            VisitParameter = VisitParameter, 
            VisitBlock = VisitBlock, 
            VisitReturnStatement = VisitReturnStatement, 
            VisitExpressionStatement = VisitExpressionStatement, 
            VisitAssignmentExpression = VisitAssignmentExpression, 
            VisitInvocationExpression = VisitInvocationExpression, 
            VisitMemberAccessExpression = VisitMemberAccessExpression, 
            VisitIdentifierName = VisitIdentifierName, 
            VisitQualifiedName = VisitQualifiedName, 
            VisitArgumentList = VisitArgumentList, 
            VisitArgument = VisitArgument, 
            VisitLiteralExpression = VisitLiteralExpression, 
            VisitLocalDeclarationStatement = VisitLocalDeclarationStatement, 
            VisitVariableDeclaration = VisitVariableDeclaration, 
            VisitVariableDeclarator = VisitVariableDeclarator, 
            VisitEqualsValueClause = VisitEqualsValueClause, 
            VisitPredefinedType = VisitPredefinedType, 
            VisitIfStatement = VisitIfStatement, 
            VisitElseClause = VisitElseClause, 
            VisitSwitchStatement = VisitSwitchStatement, 
            VisitSwitchSection = VisitSwitchSection, 
            VisitCaseSwitchLabel = VisitCaseSwitchLabel, 
            VisitBreakStatement = VisitBreakStatement, 
            VisitBinaryExpression = VisitBinaryExpression, 
            VisitPrefixUnaryExpression = VisitPrefixUnaryExpression, 
            VisitPostfixUnaryExpression = VisitPostfixUnaryExpression, 
            VisitContinueStatement = VisitContinueStatement, 
            VisitForEachStatement = VisitForEachStatement, 
            VisitWhileStatement = VisitWhileStatement, 
            VisitForStatement = VisitForStatement, 
            VisitDoStatement = VisitDoStatement, 
            VisitYieldStatement = VisitYieldStatement, 
            VisitParenthesizedExpression = VisitParenthesizedExpression, 
            VisitConditionalExpression = VisitConditionalExpression, 
            VisitGotoStatement = VisitGotoStatement, 
            VisitLabeledStatement = VisitLabeledStatement, 
            VisitEmptyStatement = VisitEmptyStatement, 
            VisitCastExpression = VisitCastExpression, 
            __staticCtor__ = __staticCtor__, 
            __ctor__ = __ctor__
        };
    end);
end);
